#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile'
source "$(which eval-helper)"

function setup-util() (
	# when running via fresh installer environment, ensure that environment gets configured
	if test -z "${DOROTHY_ENVIRONMENT-}"; then
		source "$DOROTHY/sources/environment.sh"
	fi

	local installers=(
		# intelligent
		brew
		cask

		# precompiled that autoupdate
		apt    # debian package manager (supports DEB, successor to aptitude)
		apk    # alpine package manager (supports APK)
		zypper # opensuse package manager (supports YaST, RPM)
		dnf    # fedora package manager (supports RPM, successor to yum)
		yum    # fedora package manager (supports RPM, predecessor to dnf)

		# precompiled containers that autoupdate
		snap    # dependencies are within the snap
		flatpak # dependencies are their own flatpaks, but everything is precompiled

		# precompiled AUR that autoupdates (first-class)
		pamac  # manjaro package manager: GUI+CLI, vala, wraps libalpm, snap, flatpak: https://gitlab.manjaro.org/applications/pamac/
		pacman # arch package manager: CLI, c, wraps libalpm: https://wiki.archlinux.org/title/pacman

		# precompiled AUR that autoupdates (wrappers)
		# https://wiki.archlinux.org/title/AUR_helpers
		# https://wiki.manjaro.org/index.php?title=Pamac
		# https://wiki.manjaro.org/index.php/Arch_User_Repository
		# https://itsfoss.com/paru-aur-helper/
		# https://itsfoss.com/best-aur-helpers/
		yay      # GUI, go, wraps pacman: https://github.com/Jguer/yay
		paru     # CLI, rust, wraps pacman: https://github.com/Morganamilo/paru
		pakku    # CLI, nim, wraps pacman: https://github.com/kitsunyan/pakku
		aurutils # CLI, shell, wraps pacman: https://github.com/AladW/aurutils

		# precompile that does not autoupdate
		dpkg # is available on debian, however apt is preferred
		rpm  # is available on opensuse, however zypper is preferred

		# source that needs compiling and does autuupdate
		# preferred over JIT as if provided, this will be faster
		cargo
		go

		# source that is JIT
		npm
		pip
		pipx
		gem

		# precompiled that autoupdates, but interferes with unix
		choco # windows package manager

		# unknown
		cabal
		conda
		dnf
		doas
		emerge
		eopkg
		guix
		huber
		nix
		pkg
		pkgin
		pkgman
		pkgutil
		port
		scoop
		stack
		winget
		xbps

		# custom
		installer # local or remote installer
		github    # remote executable download from github, supports zip
		download  # remote executable download, supports zip
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Install a utility with support for several package managers.

			USAGE:
			setup-util [...options] -- [order of installers]

			OPTIONS:
			--cli=<cli>
			    Used to check if the utility is already installed.

			--app=<app>
			    Used to check if the utility is already installed.

			--name=<name>
			    The name to use for the utility in human readable output, such as log messages.

			--confirm
			    Confirm installation of the utility before installing it.

			--optional
			    If truthy, do not return a failure code if the utility was unable to be installed.

			--no-fallback
			    If truthy, do not install a package system in order to install the package.

			--upgrade
			    If truthy, if the utility is already installed then reinstall/upgrade it. Not all installers support this.

			--uninstall
			    If truthy, if the utility is already installed then uninstall it. Not all installers support this.

			--force
			    If truthy, use the installer's force mode if supported.

			--quiet
			    If unspecified, outputs only useful things.
			    If truthy, don't output anything that isn't an error message.
			    If falsey, output everything.

			... <installers> provide the remaining arguments,
			for now they are only documented in the source code.

			INSTALLERS:
			The following installers are supported, in this default order of preference:

			    ${installers[*]}

			EXAMPLE:

			setup-util --name='bottom' --cli='btm' \
			    AUR='bottom-bin' \
			    BREW='bottom' \
			    CARGO='bottom' \
			   -- aur brew cargo

			        Arguments passed to [setup-util] are used to specify a custom order of preference for installer methods, in the above example, we are saying we prefer aur then brew then cargo. The order of environment variables and flags is inconsequential.

		EOF
		return 22 # Invalid argument
	}

	# installer options
	local ALPINE=''
	local APT='' DEBIAN='' APT_REPO='' APT_KEY='' APT_ID='' APT_EVAL=''
	local AUR='' ARCH='' YAY='' PARU='' PAKKU='' AURUTILS='' PAMAC=''
	local BREW='' BREW_TAP='' CASK='' CASK_TAP=''
	local CABAL=''
	local CARGO='' RUST=''
	local CHOCO=''
	local CONDA='' CONDA_CHANNEL=''
	local DNF='' DNF_EVAL='' DNF_COPR='' DNF_REPO=''
	local DOAS=''
	local DPKG='' DPKG_EVAL=''
	local EMERGE='' EMERGE_EVAL=''
	local EOPKG='' SOLUS=''
	local FLATPAK='' FLATPAK_REPO=''
	local GEM='' RUBY='' GEM_EVAL='' GEM_VERSION=''
	local GO=''
	local GUIX=''
	local HUBER=''
	local NIX=''
	local NPM='' NODE='' NPM_EVAL='' NPM_FORCE=''
	local PACMAN=''
	local PIPX='' PIP='' PYTHON='' PIP_EVAL=''
	local PKG=''
	local PKGADD=''
	local PKGIN=''
	local PKGMAN=''
	local PKGUTIL=''
	local PORT=''
	local RPM=''
	local SCOOP=''
	local SNAP='' SNAP_CHANNEL=''
	local STACK=''
	local WINGET=''
	local XBPS='' VOID=''
	local YUM='' YUM_REPO='' YUM_EVAL=''
	local ZYPPER='' ZYPPER_EVAL='' ZYPPER_REPO=''
	local INSTALLER='' INSTALLER_FILENAME='' INSTALLER_OPEN=''
	local DOWNLOAD='' DOWNLOAD_FILENAME='' DOWNLOAD_UNZIP_FORMAT='' DOWNLOAD_UNZIP_FILTER=''
	local GITHUB_SLUG='' GITHUB_FILENAME='' GITHUB_REF='' GITHUB_RELEASE='' GITHUB_PATHNAME='' GITHUB_ASSET_FILTER='' GITHUB_UNZIP_FORMAT='' GITHUB_UNZIP_FILTER=''

	# process
	local item app='' cli='' name='' quiet confirm='no' optional='no' fallback='yes' upgrade='no' force='no' uninstall='no' order=()
	quiet="$(echo-quiet -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--app='*) app="${item:6}" ;;
		'--cli='*) cli="${item:6}" ;;
		'--name='*) name="${item:7}" ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		'--no-confirm'* | '--confirm'*)
			confirm="$(
				get-flag-value confirm --missing="$confirm" -- "$item" | echo-affirmative
			)"
			;;
		'--no-optional'* | '--optional'*)
			optional="$(
				get-flag-value optional --missing="$optional" -- "$item" | echo-affirmative
			)"
			;;
		'--no-fallback'* | '--fallback'*)
			fallback="$(
				get-flag-value fallback --missing="$fallback" -- "$item" | echo-affirmative
			)"
			;;
		'--no-upgrade'* | '--upgrade'*)
			upgrade="$(
				get-flag-value upgrade --missing="$upgrade" -- "$item" | echo-affirmative
			)"
			;;
		'--no-uninstall'* | '--uninstall'*)
			uninstall="$(
				get-flag-value uninstall --missing="$uninstall" -- "$item" | echo-affirmative
			)"
			;;
		'--no-force'* | '--force'*)
			force="$(
				get-flag-value force --missing="$force" -- "$item" | echo-affirmative
			)"
			;;
		'--')
			order+=("$@")
			shift $#
			break
			;;

			# installer options
		'ALPINE='*) ALPINE="${item#*ALPINE=}" ;;
		'APT_EVAL='*) APT_EVAL="${item#*APT_EVAL=}" ;;
		'APT_ID='*) APT_ID="${item#*APT_ID=}" ;;
		'APT_KEY='*) APT_KEY="${item#*APT_KEY=}" ;;
		'APT_REPO='*) APT_REPO="${item#*APT_REPO=}" ;;
		'APT='*) APT="${item#*APT=}" ;;
		'ARCH='*) ARCH="${item#*ARCH=}" ;;
		'AUR='*) AUR="${item#*AUR=}" ;;
		'AURUTILS='*) AURUTILS="${item#*AURUTILS=}" ;;
		'BREW_TAP='*) BREW_TAP="${item#*BREW_TAP=}" ;;
		'BREW='*) BREW="${item#*BREW=}" ;;
		'CABAL='*) CABAL="${item#*CABAL=}" ;;
		'CARGO='*) CARGO="${item#*CARGO=}" ;;
		'CASK_TAP='*) CASK_TAP="${item#*CASK_TAP=}" ;;
		'CASK='*) CASK="${item#*CASK=}" ;;
		'CHOCO='*) CHOCO="${item#*CHOCO=}" ;;
		'CONDA_CHANNEL='*) CONDA_CHANNEL="${item#*CONDA_CHANNEL=}" ;;
		'CONDA='*) CONDA="${item#*CONDA=}" ;;
		'DEBIAN='*) DEBIAN="${item#*DEBIAN=}" ;;
		'DNF_COPR='*) DNF_COPR="${item#*DNF_COPR=}" ;;
		'DNF_EVAL='*) DNF_EVAL="${item#*DNF_EVAL=}" ;;
		'DNF_REPO='*) DNF_REPO="${item#*DNF_REPO=}" ;;
		'DNF='*) DNF="${item#*DNF=}" ;;
		'DOAS='*) DOAS="${item#*DOAS=}" ;;
		'DPKG_EVAL='*) DPKG_EVAL="${item#*DPKG_EVAL=}" ;;
		'DPKG='*) DPKG="${item#*DPKG=}" ;;
		'EMERGE_EVAL='*) EMERGE_EVAL="${item#*EMERGE_EVAL=}" ;;
		'EMERGE='*) EMERGE="${item#*EMERGE=}" ;;
		'EOPKG='*) EOPKG="${item#*EOPKG=}" ;;
		'FLATPAK_REPO='*) FLATPAK_REPO="${item#*FLATPAK_REPO=}" ;;
		'FLATPAK='*) FLATPAK="${item#*FLATPAK=}" ;;
		'GEM_EVAL='*) GEM_EVAL="${item#*GEM_EVAL=}" ;;
		'GEM_VERSION='*) GEM_VERSION="${item#*GEM_VERSION=}" ;;
		'GEM='*) GEM="${item#*GEM=}" ;;
		'GO='*) GO="${item#*GO=}" ;;
		'GUIX='*) GUIX="${item#*GUIX=}" ;;
		'HUBER='*) HUBER="${item#*HUBER=}" ;;
		'NIX='*) NIX="${item#*NIX=}" ;;
		'NODE='*) NODE="${item#*NODE=}" ;;
		'NPM_EVAL='*) NPM_EVAL="${item#*NPM_EVAL=}" ;;
		'NPM_FORCE='*) NPM_FORCE="${item#*NPM_FORCE=}" ;;
		'NPM='*) NPM="${item#*NPM=}" ;;
		'PACMAN='*) PACMAN="${item#*PACMAN=}" ;;
		'PAKKU='*) PAKKU="${item#*PAKKU=}" ;;
		'PAMAC='*) PAMAC="${item#*PAMAC=}" ;;
		'PARU='*) PARU="${item#*PARU=}" ;;
		'PIP_EVAL='*) PIP_EVAL="${item#*PIP_EVAL=}" ;;
		'PIP='*) PIP="${item#*PIP=}" ;;
		'PIPX='*) PIPX="${item#*PIPX=}" ;;
		'PKG='*) PKG="${item#*PKG=}" ;;
		'PKGADD='*) PKGADD="${item#*PKGADD=}" ;;
		'PKGIN='*) PKGIN="${item#*PKGIN=}" ;;
		'PKGMAN='*) PKGMAN="${item#*PKGMAN=}" ;;
		'PKGUTIL='*) PKGUTIL="${item#*PKGUTIL=}" ;;
		'PORT='*) PORT="${item#*PORT=}" ;;
		'PYTHON='*) PYTHON="${item#*PYTHON=}" ;;
		'RPM='*) RPM="${item#*RPM=}" ;;
		'RUBY='*) RUBY="${item#*RUBY=}" ;;
		'RUST='*) RUST="${item#*RUST=}" ;;
		'SCOOP='*) SCOOP="${item#*SCOOP=}" ;;
		'SNAP_CHANNEL='*) SNAP_CHANNEL="${item#*SNAP_CHANNEL=}" ;;
		'SNAP='*) SNAP="${item#*SNAP=}" ;;
		'SOLUS='*) SOLUS="${item#*SOLUS=}" ;;
		'STACK='*) STACK="${item#*STACK=}" ;;
		'VOID='*) VOID="${item#*VOID=}" ;;
		'WINGET='*) WINGET="${item#*WINGET=}" ;;
		'XBPS='*) XBPS="${item#*XBPS=}" ;;
		'YAY='*) YAY="${item#*YAY=}" ;;
		'YUM_EVAL='*) YUM_EVAL="${item#*YUM_EVAL=}" ;;
		'YUM_REPO='*) YUM_REPO="${item#*YUM_REPO=}" ;;
		'YUM='*) YUM="${item#*YUM=}" ;;
		'ZYPPER_EVAL='*) ZYPPER_EVAL="${item#*ZYPPER_EVAL=}" ;;
		'ZYPPER_REPO='*) ZYPPER_REPO="${item#*ZYPPER_REPO=}" ;;
		'ZYPPER='*) ZYPPER="${item#*ZYPPER=}" ;;
		'INSTALLER='*) INSTALLER="${item#*INSTALLER=}" ;;
		'INSTALLER_FILENAME='*) INSTALLER_FILENAME="${item#*INSTALLER_FILENAME=}" ;;
		'INSTALLER_OPEN='*) INSTALLER_OPEN="${item#*INSTALLER_OPEN=}" ;;
		'DOWNLOAD='*) DOWNLOAD="${item#*DOWNLOAD=}" ;;
		'DOWNLOAD_FILENAME='*) DOWNLOAD_FILENAME="${item#*DOWNLOAD_FILENAME=}" ;;
		'DOWNLOAD_UNZIP_FORMAT='*) DOWNLOAD_UNZIP_FORMAT="${item#*DOWNLOAD_UNZIP_FORMAT=}" ;;
		'DOWNLOAD_UNZIP_FILTER='*) DOWNLOAD_UNZIP_FILTER="${item#*DOWNLOAD_UNZIP_FILTER=}" ;;
		'GITHUB_SLUG='*) GITHUB_SLUG="${item#*GITHUB_SLUG=}" ;;
		'GITHUB_REF='*) GITHUB_REF="${item#*GITHUB_REF=}" ;;
		'GITHUB_RELEASE='*) GITHUB_RELEASE="${item#*GITHUB_RELEASE=}" ;;
		'GITHUB_PATHNAME='*) GITHUB_PATHNAME="${item#*GITHUB_PATHNAME=}" ;;
		'GITHUB_ASSET_FILTER='*) GITHUB_ASSET_FILTER="${item#*GITHUB_ASSET_FILTER=}" ;;
		'GITHUB_UNZIP_FORMAT='*) GITHUB_UNZIP_FORMAT="${item#*GITHUB_UNZIP_FORMAT=}" ;;
		'GITHUB_UNZIP_FILTER='*) GITHUB_UNZIP_FILTER="${item#*GITHUB_UNZIP_FILTER=}" ;;
		'GITHUB_FILENAME='*) GITHUB_FILENAME="${item#*GITHUB_FILENAME=}" ;;
		*) ;; # passively ignore, could be custom arg, such as --paths for setup-util-plex
		esac
	done

	# ensure name fallback
	if test -z "$name" -a -n "$cli"; then
		name="$cli"
	fi
	if test -z "$name" -a -n "$app"; then
		name="$app"
	fi
	if test -z "$name"; then
		echo-style --error="Either <name>, <cli>, <app> must be provided. See [$0 --help] for usage." >/dev/stderr
		return 22 # EINVAL 22 Invalid argument
	fi

	# ensure order
	local temp_order installer inject_installer
	if test "${#order[@]}" -eq 0; then
		order=("${installers[@]}")
	else
		# custom order, handle ...
		# so [snap ...] means snap first, then everything else, whereas [... apt] means everyting then apt
		# as such, the specified installers need to be trimmed from the ... substitution
		# @todo this will currently hard fail if there is two ... occurences
		temp_order=()
		for installer in "${order[@]}"; do
			if test "$installer" = '...'; then
				for inject_installer in "${installers[@]}"; do
					if is-needle "$inject_installer" "${order[@]}"; then
						continue
					else
						temp_order+=("$inject_installer")
					fi
				done
			else
				temp_order+=("$installer")
			fi
		done
		order=("${temp_order[@]}")
	fi

	# if uninstall is enabled, disable upgrade
	if test "$uninstall" = 'yes'; then
		upgrade='no'
	fi

	# =====================================
	# Process

	# prepare fallbacks, for when the package could be installed, but requires the package system to sshe installed first
	# which will be used, if none of the package systems were present, as such proceed in order of preference for installation of package systems
	local fallbacks=()

	# check if necessary
	if test -n "$cli" -o -n "$app"; then
		if (test -n "$app" && ! get-app "$app") || (test -n "$cli" && command-missing "$cli"); then
			# not installed
			if test "$uninstall" = 'yes'; then
				# uninstall, so no need to install
				if test "$quiet" != 'yes'; then
					echo-style --g3="The [$name] utility was not found. Already uninstalled. ✅"
				fi
				# exit
				return 0
			fi
			# disable upgrade, as only for existing installs
			upgrade='no'
			# install
			echo-style --h3="The [$name] utility was not found. Installing automatically... ⏲"
		elif test "$upgrade" = 'yes'; then
			# exists, upgrade enabled
			# reinstall
			echo-style --h3="The [$name] utility is marked for upgrade. Upgrading... ⏲"
			# remove xdg bin if it exists, as we don't want conflicts if it is deprecated
			if test -n "$cli" -a -e "$XDG_BIN_HOME/$cli"; then
				rm -f "$XDG_BIN_HOME/$cli"
			fi
		elif (test -n "$cli" && ! command-working "$cli"); then
			# exists, not working
			# reinstall
			echo-style --h3="The [$name] utility via [$cli] is misbehaving. Reinstalling automatically... ⏲"
		else
			# exists, no upgrade, is working
			# all good, exit
			if test "$quiet" != 'yes'; then
				echo-style --g3="The [$name] utility is already installed. ✅"
			fi
			return 0
		fi
	fi

	# confirm if necessary
	if test "$confirm" = 'yes'; then
		if ! confirm-positive --ppid=$$ -- "Do you want to setup the [$name] utility?"; then
			# we don't want to modify it
			if test "$optional" = 'yes'; then
				# it was optional, so success case
				return 0
			else
				# it was not optional, so abort
				return 2
			fi
		fi
	fi

	# log helpers
	function get_completion_action {
		if test "$uninstall" = 'yes'; then
			echo 'uninstalled'
		elif test "$upgrade" = 'yes'; then
			echo 'upgraded'
		else
			echo 'installed'
		fi
	}
	function won {
		local method="$1"
		if test "$quiet" != 'yes'; then
			echo-style --g3="The [$name] utility was $(get_completion_action) via [$method]. ✅"
		fi
	}
	function lost {
		if test "$optional" = 'yes'; then
			echo-style --n3="The [$name] optional utility was not $(get_completion_action). ⚠️"
			return 0 # optional so ok
		else
			echo-style --e3="The [$name] required utility was not $(get_completion_action). ❌"

			return 1 # propagate the failure
		fi
	}

	# =====================================
	# Installers

	# -------------------------------------
	# MACOS

	# brew / Homebrew / macOS
	function do_brew {
		local args=() pkgs=() pkg="$BREW" tap="$BREW_TAP"

		# check applicabile
		if test -n "$pkg"; then
			# check possible
			if ! is-brew; then
				# not possible, but can be fallen back to if mac
				if is-mac; then
					fallbacks+=('brew')
				fi
				return 1
			fi

			# univeral args
			if test "$quiet" != 'no'; then
				args+=('--quiet')
			fi

			# perform tap
			if test -n "$tap"; then
				eval-helper --quiet="$quiet" -- brew tap "${args[@]}" "$tap"
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# action args
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
			if test "$uninstall" = 'yes'; then
				if brew-installed --formula -- "${pkgs[@]}"; then
					args=('uninstall' "${args[@]}" "${pkgs[@]}")
				else
					# already uninstalled
					return 0
				fi
			else
				# install/upgrade
				args=('install' "${args[@]}" "${pkgs[@]}")
			fi

			# perform action
			eval-helper --quiet="$quiet" -- brew "${args[@]}"
		else
			return 1
		fi
	}
	function do_brew_fallback {
		setup-mac-brew install # don't do --configure, as setup-util should be as automated as possible
		source "$DOROTHY/sources/environment.sh"
		do_brew "$@"
	}

	# brew / Homebrew Casks / macOS
	function do_cask {
		local args=() pkgs=() pkg="$CASK" tap="$CASK_TAP"

		# check applicable
		if test -n "$pkg"; then
			# check possible
			if ! is-brew; then
				# not possible, but can be fallen back to if mac
				if is-mac; then
					fallbacks+=('cask')
				fi
				return 1
			fi

			# univeral args
			if test "$quiet" != 'no'; then
				args+=('--quiet')
			fi

			# perform tap
			if test -n "$tap"; then
				eval-helper --quiet="$quiet" -- brew tap "${args[@]}" "$tap"
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# action args
			args+=('--cask')
			if test "$force" = 'yes'; then
				args+=('--force')
			fi
			if test "$uninstall" = 'yes'; then
				if brew-installed --cask -- "${pkgs[@]}"; then
					args=('uninstall' "${args[@]}" "${pkgs[@]}")
				else
					# already uninstalled
					return 0
				fi
			else
				# install/upgrade
				args=('install' "${args[@]}" "${pkgs[@]}")
			fi

			# perform action
			eval-helper --quiet="$quiet" -- brew "${args[@]}"
		else
			# not applicable
			return 1
		fi
	}
	function do_cask_fallback {
		setup-mac-brew install # don't do --configure, as setup-util should be as automated as possible
		source "$DOROTHY/sources/environment.sh"
		do_cask "$@"
	}

	# -------------------------------------
	# AUR

	# To determine which aur handler to use
	# Search https://archlinux.org/packages/
	# If it appears, use AUR
	# If it does not appear, use PAMAC as it is a manjaro repo

	# aur
	function do_aur {
		do_pamac
		do_pacman
		do_yay
		do_paru
		do_pakku
		do_aurutils
	}

	# pamac / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	function do_pamac {
		local args=() pkgs=() pkg="${PAMAC:-"${AUR:-"$ARCH"}"}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing pamac; then
				fallbacks+=('pamac')
				return 1
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# action args
			if test "$uninstall" = 'yes'; then
				# remove
				args+=('remove')
			else
				if test "$force" = 'yes'; then
					# force
					args+=('reinstall')
				else
					# upgrade/install
					args+=('install')
				fi
				# without [--no-upgrade] pamac upgrades everything on the system, which can be over 40GB on initial upgrades
				args+=('--no-upgrade')
			fi

			# universal args
			args+=('--no-confirm')

			# action
			eval-helper --quiet="$quiet" -- sudo pamac "${args[@]}" "${pkgs[@]}"
			# ^ sudo with pamac avoids gui sudo prompt
		else
			# not applicable
			return 1
		fi
	}
	function do_pamac_fallback {
		setup-util-pamac
		do_pamac "$@"
	}

	# pacman / Arch Linux / Manjaro
	function do_pacman {
		local args=() pkg="${PACMAN:-"${AUR:-"$ARCH"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists pacman; then
			# --noconfirm
			#   Bypass any and all “Are you sure?” messages. It’s not a good idea to do this unless you want to run pacman from a script.

			# -q, --quiet
			#   Show less information for certain query operations.

			# -y, --refresh
			#   Download fresh package databases from the server. Use twice to force a refresh even if databases are up to date.

			# -S, --sync
			#   Synchronize packages. Packages are installed directly from the remote repositories, including all dependencies required to run the packages.

			# -R, --remove
			#   Either a URL or file path can be specified. This is a “remove-then-add” process.

			# --needed
			#   Do not reinstall the targets that are already up-to-date.

			#  -U, --upgrade
			#   Upgrade or add package(s) to the system and install the required dependencies from sync repositories.

			# prepare args
			args+=('--noconfirm')
			if test "$quiet" != 'no'; then
				args+=('--quiet')
			fi

			# init the local database
			# this is needed on systems which pacman was installed
			sudo pacman-key --init

			# refresh the local database
			sudo pacman "${args[@]}" --refresh --sync

			# action args
			if test "$uninstall" = 'yes'; then
				# remove
				args+=('--remove')
			elif test "$upgrade" = 'yes'; then
				# upgrade
				args+=('--upgrade' '--needed')
			else
				# install
				args+=('--sync' '--needed')
			fi

			# action
			eval-helper --quiet="$quiet" -- sudo pacman "${args[@]}" "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# yay / AUR / Arch Linux
	# https://github.com/Jguer/yay
	function do_yay {
		local pkg="${YAY:-"${AUR:-"$ARCH"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists yay; then
			# package case
			eval-helper --quiet="$quiet" -- yay -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# paru / AUR / Arch Linux
	# https://itsfoss.com/paru-aur-helper/
	function do_paru {
		local pkg="${PARU:-"${AUR:-"$ARCH"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists paru; then
			# package case
			eval-helper --quiet="$quiet" -- paru -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pakku / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	function do_pakku {
		local pkg="${PAKKU:-"${AUR:-"$ARCH"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists pakku; then
			# package case
			eval-helper --quiet="$quiet" -- pakku -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# aurutils / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	function do_aurutils {
		local pkg="${AURUTILS:-"${AUR:-"$ARCH"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists aurutils; then
			# package case
			eval-helper --quiet="$quiet" -- aurutils -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# -------------------------------------
	# RPM

	# zypper / openSUSE / SLES
	# installs RPM files and remote YaST2 and RPM packages
	# zypper needs sudo
	# https://www.mankier.com/8/zypper
	# https://en.opensuse.org/Portal:Zypper
	# https://documentation.suse.com/smart/linux/single-html/reference-zypper-install/index.html
	function do_zypper {
		local args=() pkgs=() pkg="${ZYPPER:-"$RPM"}" __eval="$ZYPPER_EVAL" repo="$ZYPPER_REPO"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists zypper; then
				# not possible
				return 1
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# prepare ZYPPER with ZYPPER_REPO
				if test -n "$repo"; then
					# https://www.mankier.com/8/zypper
					# https://en.opensuse.org/Snap
					sudo zypper --non-interactive --gpg-auto-import-keys addrepo --refresh "$repo"
					sudo zypper --non-interactive --gpg-auto-import-keys dist-upgrade --auto-agree-with-licenses --no-confirm --from "$repo"
				fi

				# action args
				if test "$uninstall" = 'yes'; then
					args+=('remove')
				else
					# upgrade/install
					args+=('install')
				fi

				# univeral args
				args+=('--no-confirm')

				# action
				# https://www.mankier.com/8/zypper#Commands-Package_Management_Commands
				eval-helper --quiet="$quiet" -- sudo zypper --non-interactive --gpg-auto-import-keys "${args[@]}" "${pkgs[@]}"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# dnf / COPR / Fedora / CentOS / RHEL
	# installs RPM files and remote RPM packages
	# successor to yum (same api)
	# uses rpm behind the scenes
	# https://dnf.readthedocs.io/en/latest/command_ref.html
	# https://opensource.com/article/18/8/guide-yum-dnf
	# https://docs.fedoraproject.org/en-US/quick-docs/dnf/
	function do_dnf {
		local pkg="${DNF:-"$RPM"}" __eval="$DNF_EVAL" copr="$DNF_COPR" repo="$DNF_REPO"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists dnf; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# prepare DNF with DNF_COPR
				if test -n "$copr"; then
					sudo dnf copr enable -y "$copr"
				fi

				# prepare DNF with DNF_REPO
				if test -n "$repo"; then
					sudo dnf config-manager -y --add-repo "$repo"
				fi

				# install
				eval-helper --quiet="$quiet" -- sudo dnf install -y "$pkg"
			fi
		else
			return 1
		fi
	}

	# yum / rpm / RedHat / Fedora / CentOS / etc
	# installs RPM files and remote RPM packages
	# predecessor to dnf (same api)
	# uses rpm behind the scenes
	function do_yum {
		local args=() pkgs=() pkg="${YUM:-"$RPM"}" repo="$YUM_REPO" __eval="$YUM_EVAL"

		# check applicabile
		if test -n "$pkg" -o -n "$__eval"; then
			# check relevancy
			if ! command-exists yum; then
				# not possible
				return 1
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# prepare YUM with YUM_REPO if relevant
				if test -n "$repo"; then
					down --directory='/etc/yum.repos.d/' "$repo"
				fi

				# autoremove                remove all unneeded packages that were originally installed as dependencies
				# check-update              check for available package upgrades
				# clean                     remove cached data
				# distro-sync               synchronize installed packages to the latest available versions
				# install                   install a package or packages on your system
				# reinstall                 reinstall a package
				# remove                    remove a package or packages from your system
				# upgrade                   upgrade a package or packages on your system
				# upgrade-minimal           upgrade, but only 'newest' package match which fixes a problem that affects your system

				# -b, --best
				#   try the best available package versions in transactions.

				# -q, --quiet
				#   quiet operation

				# -y, --assumeyes
				#   automatically answer yes for all questions

				# action args
				if test "$uninstall" = 'yes'; then
					# remove
					args+=('remove')
				elif test "$upgrade" = 'yes'; then
					# upgrade
					args+=('upgrade')
				else
					# install
					args+=('install')
				fi

				# univeral args
				args+=('-y' '--best')
				if test "$quiet" != 'no'; then
					args+=('--quiet')
				fi

				# action
				# https://man7.org/linux/man-pages/man8/yum.8.html#COMMANDS
				eval-helper --quiet="$quiet" -- sudo yum "${args[@]}" "${pkgs[@]}"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# rpm / RedHat / Fedora / CentOS / etc
	# installs RPM files
	function do_rpm {
		local args=() pkg="$RPM"

		# check applicable
		if test -n "$pkg"; then
			# check possible
			if ! command-exists rpm; then
				# not possible
				return 1
			fi

			# action args
			if test "$uninstall" = 'yes'; then
				# remove
				args+=('--erase')
			elif test "$upgrade" = 'yes'; then
				# upgrade
				args+=('--upgrade')
			else
				# install
				args+=('--install')
			fi

			# univeral args
			if test "$quiet" != 'no'; then
				args+=('--quiet')
			fi

			# package case
			eval-helper --quiet="$quiet" -- sudo rpm "${args[@]}" "$pkg"
		else
			# not applicable
			return 1
		fi
	}

	# -------------------------------------
	# DEB

	# apt / Ubuntu / Debian / Linux Mint / elementary OS / etc
	# installs remote .deb packages
	# sucessor to aptitude
	# https://wiki.debian.org/Apt
	function do_apt_key_fetch {
		local key="$1"
		if [[ $key == *'.asc' ]]; then
			# .asc files
			fetch "$key" | gpg --dearmor
		else
			# .key and unknown files
			fetch "$key"
		fi
	}
	function do_apt {
		local args=() pkgs=() keyring='' pkg="${APT:-"$DEBIAN"}" repo="$APT_REPO" key="$APT_KEY" id="$APT_ID" __eval="$APT_EVAL"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! is-apt; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# support multiple pkgs
				mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

				# if APT_REPO or APT_KEY are used, then determine APT_ID automatically, and fail if it couldn't be determined
				if test -n "$repo" -o -n "$key"; then
					if test -z "$id"; then
						if [[ $pkg == *' '* ]]; then
							cat <<-EOF >/dev/stderr
								$(echo-style --error="If APT has multiple packages, then APT_ID must be specified.")

								APT: $pkg
								APT_KEY: $key
								APT_REPO: $repo
							EOF
							return 1
						fi
					fi
				fi

				# ensure key has repo correctly set
				if test -n "$key"; then
					if test -z "$repo"; then
						cat <<-EOF >/dev/stderr
							$(echo-style --error="If APT_KEY is set, APT_REPO must also be set.")
							APT: $pkg
							APT_KEY: $key
						EOF
						return 1
					fi
					if [[ $repo != *'signed-by'* ]]; then
						cat <<-EOF >/dev/stderr
							$(echo-style --error="If APT_KEY is set, APT_REPO must contain:")
							$(echo-style --code="deb [signed-by={KEY}] https://...")

							APT: $pkg
							APT_KEY: $key
							APT_REPO: $repo
						EOF
						return 1
					fi
				fi

				# ensure repo is correct
				if test -n "$repo"; then
					if [[ $repo != *'arch={ARCH}'* ]]; then
						cat <<-EOF >/dev/stderr
							$(echo-style --error="If APT_REPO is set, arch must be set to {ARCH}")
							$(echo-style --code="deb [arch={ARCH}] https://...")

							APT: $pkg
							APT: $pkg
							APT_REPO: $repo
						EOF
						return 1
					fi
					if [[ $repo != *'signed-by={KEY}'* ]]; then
						cat <<-EOF >/dev/stderr
							$(echo-style --error="If APT_REPO is set, signed-by must be set to {KEY}")
							$(echo-style --code="deb [signed-by={KEY}] https://...")

							APT: $pkg
							APT_REPO: $repo
						EOF
						return 1
					fi
					if [[ $repo == *'http:'* ]]; then
						# warn
						cat <<-EOF >/dev/stderr
							$(echo-style --notice="APT_REPO contained " --code="http:" --notice=" instead of " --code="https:" --notice=" this may be an oversight.")

							APT_REPO: $repo
						EOF
					fi
				fi

				# prepare APT with APT_KEY
				if test -n "$key"; then
					# Deprecated technique is:
					# fetch ... | sudo apt-key add -
					# Modern and working technique is what we do below...
					# which improves upon these incomplete and non-working suggestions:
					# https://blog.jak-linux.org/2021/06/20/migrating-away-apt-key/
					# https://packagecloud.io/blog/what-does-it-mean-to-add-a-repository-to-my-sources/#strongaddaptrepositorystrong
					# https://linuxize.com/post/how-to-add-apt-repository-in-ubuntu/
					# https://www.techrepublic.com/article/how-to-add-an-openpgp-repository-key-now-that-apt-key-is-deprecated/
					# https://stackoverflow.com/a/69015383/130638
					# https://askubuntu.com/a/1307181
					# https://askubuntu.com/a/1306494

					# prepare new location
					sudo mkdir -p /usr/local/share/keyrings/
					keyring="/usr/local/share/keyrings/$id.gpg"

					# remove old keys
					sudo rm -f /usr/local/share/keyrings/*"$id"*
					sudo rm -f /etc/apt/trusted.gpg.d/*"$id"*

					# helper for quiet output
					function do_apt_key_add {
						# fetch and convert format, then import with export into correct format
						do_apt_key_fetch "$key" | sudo gpg \
							--no-default-keyring \
							--keyring="gnupg-ring:$keyring" \
							--import # uses stdin
						# [gnupg-ring:] prefix creates keyring in apt compatible (legacy) v4 format

						# adjust permission to fix [_apt access error] on ubuntu 21.10
						sudo chmod a+r "$keyring"
					}
					eval-helper --quiet="$quiet" -- do_apt_key_add
				fi

				# prepare APT with APT_REPO
				if test -n "$repo"; then
					# remove old listings
					sudo rm -f /etc/apt/sources.list.d/*"$id"*

					# add the repo with appropriate technique for the repo type
					if [[ $repo == 'deb '* ]]; then
						# adjust key modifier
						repo="${repo/"{KEY}"/"$keyring"}"

						# adjust arch modifier
						repo="${repo/"{ARCH}"/"$(
							dpkg --print-architecture
						)"}"

						# adjust release modifier
						repo="${repo/"{RELEASE}"/"$(
							lsb_release --codename --short
						)"}"

						# use a non-deprecated technique that supports the deb modifiers
						echo "$repo" | sudo tee "/etc/apt/sources.list.d/$id.list" >/dev/null
					else
						# [apt-add-repository --help] notes [sudo apt-add-repository -y "$repo"] is deprecated
						# however the alternative for `ppa:` and other syntax is too complicated
						eval-helper --quiet="$quiet" -- sudo apt-add-repository -y --enable-source "$repo"
					fi

					# to debug:
					# sudo apt-add-repository --list
				fi

				# if we added a new repo or key, we need to refresh the apt references
				if test -n "$repo" -o -n "$key"; then
					eval-helper --quiet="$quiet" -- sudo apt-get update -y
				fi

				# action args
				if test "$uninstall" = 'yes'; then
					args+=('remove' '-y' '--purge')
				else
					# install/upgrade
					args+=('install' '-y' '--fix-broken')
				fi

				# action
				eval-helper --quiet="$quiet" -- sudo apt-get "${args[@]}" "${pkgs[@]}"
				# use `apt-get`, as `apt` produces this warning on Ubuntu 20.04.3 LTS
				# WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
			fi
		else
			# not applicable
			return 1
		fi
	}

	# dpkg / Debian / Ubuntu / Linux Mint / elementary OS / etc
	# installs .deb files
	function do_dpkg {
		local pkg="$DPKG" __eval="$DPKG_EVAL"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists dpkg; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				eval-helper --quiet="$quiet" -- sudo dpkg --install "$pkg"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# -------------------------------------
	# SYSTEM

	# apk / Alpine Linux
	# https://wiki.alpinelinux.org/wiki/Package_management
	function do_apk {
		local args=() pkgs=() pkg="${APK:-"$ALPINE"}"

		# check applicable and possible
		if test -n "$pkg" && command-exists apk; then
			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# action args
			if test "$uninstall" = 'yes'; then
				args+=('del')
			else
				# upgrade/install
				args+=('add')
			fi

			# univeral args
			args+=('--update-cache')

			# action
			eval-helper --quiet="$quiet" -- apk "${args[@]}" "${pkgs[@]}"
		else
			# not needed
			return 1
		fi
	}

	# choco / Chocolatey / Windows
	# https://docs.chocolatey.org/en-us/choco/setup
	# https://docs.chocolatey.org/en-us/choco/commands/
	# https://community.chocolatey.org/packages
	function do_choco {
		local args=() pkg="$CHOCO"

		# check applicable and possible
		if test -n "$pkg" && command-exists choco; then
			# univeral args
			args+=('--accept-license')

			# action args
			if test "$uninstall" = 'yes'; then
				# https://docs.chocolatey.org/en-us/choco/commands/uninstall
				args+=('uninstall')
			elif test "$upgrade" = 'yes'; then
				# https://docs.chocolatey.org/en-us/choco/commands/upgrade
				args+=('upgrade')
			else
				# https://docs.chocolatey.org/en-us/choco/commands/install
				args+=('install')
			fi

			eval-helper --quiet="$quiet" -- choco "${args[@]}" "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# -------------------------------------
	# CONTAINERS

	# flatpak / Arch Linux / Manjaro
	function do_flatpak {
		# accomodate flatpak typos
		local args=() pkgs=() pkg="$FLATPAK" repo="$FLATPAK_REPO"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing flatpak; then
				fallbacks+=('flatpak')
				return 1
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# ensure repo
			if test -z "$repo"; then
				repo='flathub'
			fi

			# action args
			if test "$uninstall" = 'yes'; then
				args+=('uninstall')
			else
				if test "$upgrade" = 'yes'; then
					args+=('update')
					if test "$force" = 'yes'; then
						args+=('--force-remove')
					fi
				else
					args+=('install' '--or-update')
					if test "$force" = 'yes'; then
						args+=('--reinstall')
					fi
				fi
			fi

			# universal args
			args+=('-y' '--noninteractive')

			# action
			# https://manpages.org/flatpak-install
			for pkg in "${pkgs[@]}"; do
				eval-helper --quiet="$quiet" -- sudo flatpak "${args[@]}" "$pkg"
				# ^ sudo with flatpak avoids gui sudo prompt
			done
		else
			# not applicable
			return 1
		fi
	}
	function do_flatpak_fallback {
		setup-util-flatpak
		do_flatpak "$@"
	}

	# snap / Snap Craft / Ubuntu
	function do_snap {
		local args=() pkg="$SNAP" channel="$SNAP_CHANNEL"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing snap; then
				fallbacks+=('snap')
				return 1
			fi

			# compatibility check
			if ! is-snap; then
				return 1
			fi

			# support multiple args inside SNAP
			mapfile -t args < <(echo-split ' ' -- "$pkg")

			# action args
			if test "$uninstall" = 'yes'; then
				# remove
				args=('remove' "${args[@]}")
			else
				# upgrade/install
				args=('install' "${args[@]}")

				# optional `--channel=...` if `SNAP_CHANNEL` is present
				if test -n "$channel"; then
					args+=("--channel=$channel")
				fi
			fi

			# action
			eval-helper --quiet="$quiet" -- sudo snap "${args[@]}"
			# ^ needs sudo, otherwise: error: access denied (try with sudo)
		else
			# not applicable
			return 1
		fi
	}
	function do_snap_fallback {
		setup-util-snap
		do_snap "$@"
	}

	# -------------------------------------
	# COMPILE

	# cargo / Crates.io / Rust
	function do_cargo {
		local pkg="${CARGO:-"$RUST"}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing cargo; then
				fallbacks+=('cargo')
				return 1
			fi

			# package case
			if test "$quiet" != 'yes'; then
				log-performance
			fi
			eval-helper --quiet="$quiet" -- cargo install "$pkg"
		else
			# not applicable
			return 1
		fi
	}
	function do_cargo_fallback {
		setup-rust
		source "$DOROTHY/sources/environment.sh"
		do_cargo "$@"
	}

	# go
	function do_go {
		local pkg="$GO"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing go; then
				fallbacks+=('go')
				return 1
			fi

			# add version if not there
			if [[ $pkg != *'@'* ]]; then
				pkg="${pkg}@latest"
			fi

			# package case
			eval-helper --quiet="$quiet" -- go install -v "$pkg"
		else
			# not applicable
			return 1
		fi
	}
	function do_go_fallback {
		setup-go
		source "$DOROTHY/sources/environment.sh"
		do_go "$@"
	}

	# -------------------------------------
	# JIT

	# gem / Ruby
	# we use --user-install because of:
	# https://github.com/ffi/ffi/issues/631
	function do_gem {
		local pkg="${GEM:-"$RUBY"}" __eval="$GEM_EVAL" version="$GEM_VERSION"

		# check relevancy
		if test -n "$pkg" -o -n "$__eval"; then
			# check requisites
			if command-missing gem; then
				fallbacks+=('gem')
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				gem uninstall "$pkg" -axI &>/dev/null
				if test -n "$version"; then
					eval-helper --quiet="$quiet" -- gem install "$pkg" --version "$version" --user-install --no-document
				else
					eval-helper --quiet="$quiet" -- gem install "$pkg" --user-install --no-document
				fi
			fi
		else
			# not applicable
			return 1
		fi
	}
	function do_gem_fallback {
		setup-ruby
		source "$DOROTHY/sources/environment.sh"
		do_gem "$@"
	}

	# npm / Node.js
	function do_npm {
		local cmd=() pkgs=() pkg="${NPM:-"$NODE"}" __eval="$NPM_EVAL" force="$NPM_FORCE"

		if test -n "$pkg" -o -n "$__eval"; then
			# load nvm in case there is no system node
			# or in case of user-preference to use nvm over system node
			source "$DOROTHY/sources/nvm.sh"

			# fallback case
			if command-missing npm; then
				fallbacks+=('npm')
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# support multiple pkgs
				cmd=('npm' 'install' '--global')
				mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

				# optional --force
				if is-affirmative -- "$force"; then
					cmd+=('--force')
				fi

				# install
				eval-helper --quiet="$quiet" -- "${cmd[@]}" "${pkgs[@]}"
			fi
		else
			# not applicable
			return 1
		fi
	}
	function do_npm_fallback {
		setup-node
		source "$DOROTHY/sources/environment.sh"
		set +e # nvm prevents strict from working: .nvm/nvm.sh: line 1966: TMPDIR: unbound variable
		source "$DOROTHY/sources/nvm.sh"
		do_npm "$@"
	}

	# pip / Python
	function pip_helper {
		# Use the correct [pip] executable for the user's environment, as there may be many or multiple installed, such as one for Python v2 and one for Python v3.
		if command-exists pip; then
			pip "$@"
		elif python -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists pip3; then
			pip3 "$@"
		elif python3 -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists pip2; then
			pip2 "$@"
		elif python2 -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists /usr/local/bin/pip; then
			/usr/local/bin/pip "$@"
		elif test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/pip"; then
			"${HOMEBREW_PREFIX}/bin/pip" "$@"
		else
			echo-style --error="[pip] nor its variations were found" >/dev/stderr
			return 1
		fi
	}
	function do_pip {
		local pkgs=() pkg="${PIP:-"$PYTHON"}" __eval="$PIP_EVAL"

		if test -n "$pkg" -o -n "$__eval"; then
			# fallback case
			if ! pip_helper --version &>/dev/null; then
				fallbacks+=('pip')
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# support multiple pkgs
				mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

				# install
				eval-helper --quiet="$quiet" -- pip_helper install --user --upgrade --force-reinstall --no-warn-script-location "${pkgs[@]}"
			fi
		else
			# not applicable
			return 1
		fi
	}
	function do_pip_fallback {
		setup-python
		source "$DOROTHY/sources/environment.sh"
		do_pip "$@"
	}

	# pipx / Python
	function do_pipx {
		local pkgs=() pkg="${PIPX:-"$PYTHON"}"

		# check applicablity
		if test -n "$pkg"; then
			# fallback case
			if command-missing pipx; then
				fallbacks+=('pipx')
				return 1
			fi

			# support multiple pkgs
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# package case
			eval-helper --quiet="$quiet" -- pipx install "${pkgs[@]}"
		else
			# not applicable
			return 1
		fi
	}
	function do_pipx_fallback {
		if ! pip_helper --version &>/dev/null; then
			setup-python
		fi
		setup-util-pipx
		source "$DOROTHY/sources/environment.sh"
		do_pipx "$@"
	}

	# -------------------------------------
	# UNKNOWN

	# nix
	function do_nix {
		local pkg="$NIX"

		# check applicable and possible
		if test -n "$pkg" && command-exists nix-env; then
			eval-helper --quiet="$quiet" -- nix-env -iA "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# xbps / Void Linux
	function do_xbps {
		local pkg="${XBPS:-"$VOID"}"

		# check applicable and possible
		if test -n "$pkg" && command-exists xbps-install; then
			eval-helper --quiet="$quiet" -- xbps-install -S "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# eopkg / Solus
	function do_eopkg {
		local pkg="${EOPKG:-"$SOLUS"}"

		# check applicable and possible
		if test -n "$pkg" && command-exists eopkg; then
			eval-helper --quiet="$quiet" -- sudo eopkg it "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# emerge / GURU / Gentoo Linux
	function do_emerge {
		# @todo add EMERGE_REPO, see zoxide for example
		local pkg="$EMERGE" __eval="$EMERGE_EVAL"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists emerge; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				eval-helper --quiet="$quiet" -- sudo emerge -av "$pkg"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# port / MacPorts
	function do_port {
		local pkg="$PORT"

		# check applicable and possible
		if test -n "$pkg" && command-exists port; then
			eval-helper --quiet="$quiet" -- sudo port install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# scoop / Windows
	function do_scoop {
		local pkg="$SCOOP"

		# check applicable and possible
		if test -n "$pkg" && command-exists scoop; then
			eval-helper --quiet="$quiet" -- scoop install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# winget / Windows Package Manager Client
	function do_winget {
		local pkg="$WINGET"

		# check applicable and possible
		if test -n "$pkg" && command-exists winget; then
			eval-helper --quiet="$quiet" -- winget install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkg / FreeBSD / Termux
	function do_pkg {
		local pkg="$PKG"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkg; then
			eval-helper --quiet="$quiet" -- pkg install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkgutil / Solaris 10+, Sparc and x86.
	function do_pkgutil {
		local pkg="$PKGUTIL"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkgutil; then
			eval-helper --quiet="$quiet" -- pkgutil -i "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# huber
	function do_huber {
		local pkg="$HUBER"

		# check applicable and possible
		if test -n "$pkg" && command-exists huber; then
			eval-helper --quiet="$quiet" -- huber install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# guix
	function do_guix {
		local pkg="$GUIX"

		# check applicable and possible
		if test -n "$pkg" && command-exists guix; then
			eval-helper --quiet="$quiet" -- guix package -i "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# doas / Solaris
	function do_doas {
		local pkg="$DOAS"

		# check applicable and possible
		if test -n "$pkg" && command-exists doas; then
			eval-helper --quiet="$quiet" -- doas pkg_add "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkg_add / OpenBSD
	function do_pkg {
		local pkg="$PKGADD"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkg_add; then
			eval-helper --quiet="$quiet" -- pkg_add "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkgin/ NetBSD
	function do_pkgin {
		local pkg="$PKGIN"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkgin; then
			eval-helper --quiet="$quiet" -- pkgin install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkgman / Haiku
	function do_pkgman {
		local pkg="$PKGMAN"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkgman; then
			eval-helper --quiet="$quiet" -- pkgman install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# stack
	function do_stack {
		local pkg="$STACK"

		# check applicable and possible
		if test -n "$pkg" && command-exists stack; then
			stack update
			eval-helper --quiet="$quiet" -- stack install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# cabal
	function do_cabal {
		local pkg="$CABAL"

		# check applicable and possible
		if test -n "$pkg" && command-exists cabal; then
			cabal update
			eval-helper --quiet="$quiet" -- cabal install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# conda
	function do_conda {
		local pkg="$CONDA" channel="$CONDA_CHANNEL"

		# check applicable and possible
		# require channel to be defined, as CONDA is always present on github CI
		if test -n "$pkg" -a "$channel" && command-exists conda; then
			eval-helper --quiet="$quiet" -- conda install -c "$channel" "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# ---------------------------------
	# CUSTOM

	# installer
	function do_installer {
		local args=() file file_or_url="$INSTALLER" filename="$INSTALLER_FILENAME" __open="$INSTALLER_OPEN"

		# check applicabile
		if test -n "$file_or_url"; then
			# optional filename
			if test -z "$filename"; then
				# include extension
				filename="$(basename "$file_or_url")"
			fi

			# check if it is local, or remote
			if test -e "$file_or_url"; then
				file="$file_or_url"
			else
				# it is remote
				# download it to a temporary location and use that
				file="$(
					fs-temp \
						--directory='setup-util' \
						--directory="$name" \
						--file="$filename"
				)"
				down "$file_or_url" --path="$file"
			fi
			# ensure it is executable, then open or run it
			chmod +x "$file"
			if test "$__open" = 'yes'; then
				open "$file"
			elif [[ $file == *'/setup-util-'* ]]; then
				# dorothy installer
				# in which case forward the arguments
				# and note SETUP_UTIL=yes to prevent recursion
				# but do not forward order, as the installer may have custom arguments
				eval-helper --quiet="$quiet" -- env SETUP_UTIL=yes "$file" \
					--confirm="$confirm" \
					--optional="$optional" \
					--upgrade="$upgrade" \
					--uninstall="$uninstall" \
					--force="$force" \
					--quiet="$quiet"
			else
				# external installer script
				eval-helper --quiet="$quiet" -- "$file"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# github
	function do_github {
		local file slug="$GITHUB_SLUG" filename="$GITHUB_FILENAME" ref="$GITHUB_REF" release="$GITHUB_RELEASE" pathname="$GITHUB_PATHNAME" asset_filter="$GITHUB_ASSET_FILTER" unzip_format="$GITHUB_UNZIP_FORMAT" unzip_filter="$GITHUB_UNZIP_FILTER"

		# check applicabile
		if test -n "$slug"; then
			# require filename
			if test -z "$filename"; then
				echo-style --error="GITHUB requires GITHUB_FILENAME"
				return 1
			fi

			# prepare
			mkdir -p "$XDG_BIN_HOME"
			file="$XDG_BIN_HOME/$filename"

			# uninstall?
			if test "$uninstall" = 'yes'; then
				rm -f "$file"
				return 0
			fi

			# download
			github-download \
				--quiet="$quiet" \
				--slug="$slug" \
				--ref="$ref" \
				--release="$release" \
				--pathname="$pathname" \
				--asset-filter="$asset_filter" \
				--unzip-format="$unzip_format" \
				--unzip-filter="$unzip_filter" \
				--path="$file"

			# verify
			if test ! -e "$file"; then
				echo-style --error='Failed to install:' ' ' --code="$file"
				return 1
			fi

			# adjust
			fs-own --permissions='+x' -- "$file"

			# verify
			if ! command-working "$file"; then
				echo-style --error='Failed to verify:' ' ' --code="$file"
				return 1
			fi
		else
			# not applicable
			return 1
		fi
	}

	# download
	function do_download {
		local file download="$DOWNLOAD" filename="$DOWNLOAD_FILENAME" unzip_format="$DOWNLOAD_UNZIP_FORMAT" unzip_filter="$DOWNLOAD_UNZIP_FILTER"

		# check applicabile
		if test -n "$download"; then
			# require filename
			if test -z "$filename"; then
				echo-style --error="DOWNLOAD requires DOWNLOAD_FILENAME"
				return 1
			fi

			# prepare
			file="$XDG_BIN_HOME/$filename"
			mkdir -p "$XDG_BIN_HOME"

			# uninstall?
			if test "$uninstall" = 'yes'; then
				rm -f "$file"
				return 0
			fi

			# download
			down "$download" \
				--quiet="$quiet" \
				--unzip-format="$unzip_format" \
				--unzip-filter="$unzip_filter" \
				--path="$file"

			# verify
			if test ! -e "$file"; then
				echo-style --error='Failed to install:' ' ' --code="$file"
				return 1
			fi

			# adjust
			fs-own --permissions='+x' -- "$file"

			# verify
			if ! command-working "$file"; then
				echo-style --error='Failed to verify:' ' ' --code="$file"
				return 1
			fi
		else
			# not applicable
			return 1
		fi
	}

	# =====================================
	# Action

	local installer

	# cycle through the order
	for installer in "${order[@]}"; do
		# sanity check
		if test -z "$installer"; then
			echo-style --error="an empty order argument was provided"
			echo-verbose "${order[@]}"
			return 22 # Invalid argument
		fi
		# # this installer was disabled, ignore
		# if test -z "$installer"; then
		# 	continue
		# fi
		# attempt installation
		if "do_${installer}"; then
			won "$installer"
			return 0
		fi
	done

	# fallback for failed packages which are missing their package system
	if test "$fallback" = 'yes'; then
		if test "${#fallbacks[@]}" -ne 0; then
			for installer in "${fallbacks[@]}"; do
				if "do_${installer}_fallback"; then
					won "$installer"
					return 0
				fi
			done
		fi
	fi

	# failure
	lost
	return "$?"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup-util "$@"
fi
