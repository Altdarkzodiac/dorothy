#!/usr/bin/env bash
# shellcheck disable=SC2164,SC1091,SC2178
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile'

function setup-util() (
	local installers=(
		# intelligent
		brew
		cask

		# precompiled
		pacman
		apt
		apk
		yum # also rpm

		# precompiled containers
		snap

		# source containers
		flatpak

		# aur
		# https://itsfoss.com/paru-aur-helper/
		# https://itsfoss.com/best-aur-helpers/
		yay
		pakku
		paru
		aurutils
		pamac

		# source
		cargo
		npm
		go
		pip
		pipx
		gem

		# unknown
		cabal
		choco
		conda
		dnf
		doas
		dpkg
		emerge
		eopkg
		guix
		huber
		nix
		pkg
		pkgin
		pkgman
		pkgutil
		port
		scoop
		stack
		winget
		xbps
		zypper

		# custom
		installer # local or remote installer
		github    # remote executable download from github, supports zip
		download  # remote executable download, supports zip
	)

	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Install a utility with support for several package managers.

			USAGE:
			setup-util [...options] -- [order of installers]

			OPTIONS:
			CLI=<cli> | --cli=<cli>
			    Used to check if the utility is already installed.

			NAME=<name> | --name=<...> | env NAME=<...> setup-util
			    The name to use for the utility in human readable output, such as log messages.

			--confirm
			    Confirm installation of the utility before installing it.

			--optional
			    If truthy, do not return a failure code if the utility was unable to be installed.

			--upgrade
			    If truthy, if the installer is already installed (determined by the CLI flag), reinstall/upgrade it.

			--force
			    If truthy, use the installer's force mode if supported.

			--quiet
			    If unspecified, outputs only useful things.
			    If truthy, don't output anything that isn't an error message.
			    If falsey, output everything.

			... <installers> provide the remaining arguments,
			for now they are only documented in the source code.

			INSTALLERS:
			The following installers are supported, in this default order of preference:

			    ${installers[*]}

			EXAMPLE:

			setup-util NAME='bottom' CLI='btm' \
			    AUR='bottom-bin' \
			    BREW='bottom' \
			    CARGO='bottom' \
			   -- aur brew cargo

			        Arguments passed to [setup-util] are used to specify a custom order of preference for installer methods, in the above example, we are saying we prefer aur then brew then cargo. The order of environment variables and flags is inconsequential.

		EOF
		return 22 # Invalid argument
	}

	# installer options
	local BREW='' HOMEBREW='' CASK=''
	local PACMAN=''
	local AUR='' ARCH='' YAY='' PARU='' PAKKU='' AURUTILS='' PAMAC=''
	local FLATPAK='' FLATPACK='' FLATPAK_REPO='' FLATPACK_REPO=''
	local SNAP='' SNAP_CHANNEL='' SNAP_CLASSIC=''
	local YUM='' RPM='' YUM_REPO='' YUM_EVAL=''
	local APT='' DEBIAN='' APT_REPO='' APT_KEY='' APT_KEY_NAME='' APT_EVAL=''
	local ALPINE=''
	local NIX=''
	local XBPS='' VOID=''
	local EOPKG='' SOLUS=''
	local EMERGE='' EMERGE_EVAL=''
	local DNF='' DNF_EVAL='' DNF_COPR='' DNF_REPO=''
	local ZYPPER='' ZYPPER_EVAL='' ZYPPER_REPO=''
	local PORT=''
	local CHOCO=''
	local SCOOP=''
	local WINGET=''
	local PKG=''
	local PKGUTIL=''
	local HUBER=''
	local GUIX=''
	local DPKG=''
	local DPKG_EVAL=''
	local DOAS=''
	local PKGADD=''
	local PKGIN=''
	local PKGMAN=''
	local STACK=''
	local CABAL=''
	local CONDA='' CONDA_CHANNEL=''
	local NPM='' NODE='' NPM_EVAL='' NPM_FORCE=''
	local GO=''
	local PIPX='' PIP='' PYTHON='' PIP_EVAL=''
	local GEM='' RUBY='' GEM_EVAL='' GEM_VERSION=''
	local CARGO='' RUST=''
	local INSTALLER='' INSTALLER_OPEN=''
	local DOWNLOAD='' DOWNLOAD_FILENAME='' DOWNLOAD_UNZIP_FORMAT='' DOWNLOAD_UNZIP_FILTER=''
	local GITHUB_SLUG='' GITHUB_FILENAME='' GITHUB_RELEASE='' GITHUB_ASSET_FILTER='' GITHUB_UNZIP_FORMAT='' GITHUB_UNZIP_FILTER=''

	# process
	local item cli='' name='' quiet confirm='' optional='' upgrade='' force='' order=()
	quiet="$(echo-quiet -- "$@")"
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--cli='*) cli="${item:5}" ;;
		'--name='*) name="${item:6}" ;;
		'CLI='*) cli="${item:4}" ;;
		'NAME='*) name="${item:5}" ;;
		'--no-quiet'* | '--quiet'* | '--no-verbose'* | '--verbose'*) ;; # handled by echo-quiet
		'--no-confirm'* | '--confirm'*)
			confirm="$(
				get-flag-value confirm --missing="$confirm" -- "$item" | echo-affirmative
			)"
			;;
		'--no-optional'* | '--optional'*)
			optional="$(
				get-flag-value optional --missing="$optional" -- "$item" | echo-affirmative
			)"
			;;
		'--no-upgrade'* | '--upgrade'*)
			upgrade="$(
				get-flag-value upgrade --missing="$upgrade" -- "$item" | echo-affirmative
			)"
			;;
		'--no-force'* | '--force'*)
			force="$(
				get-flag-value force --missing="$force" -- "$item" | echo-affirmative
			)"
			;;
		'--')
			order+=("$@")
			shift $#
			break
			;;

			# installer options
		'BREW='*) BREW="${item#*BREW=}" ;;
		'HOMEBREW='*) HOMEBREW="${item#*HOMEBREW=}" ;;
		'CASK='*) CASK="${item#*CASK=}" ;;
		'PACMAN='*) PACMAN="${item#*PACMAN=}" ;;
		'AUR='*) AUR="${item#*AUR=}" ;;
		'ARCH='*) ARCH="${item#*ARCH=}" ;;
		'YAY='*) YAY="${item#*YAY=}" ;;
		'PARU='*) PARU="${item#*PARU=}" ;;
		'PAKKU='*) PAKKU="${item#*PAKKU=}" ;;
		'AURUTILS='*) AURUTILS="${item#*AURUTILS=}" ;;
		'PAMAC='*) PAMAC="${item#*PAMAC=}" ;;
		'FLATPAK='*) FLATPAK="${item#*FLATPAK=}" ;;
		'FLATPACK='*) FLATPACK="${item#*FLATPACK=}" ;;
		'FLATPAK_REPO='*) FLATPAK_REPO="${item#*FLATPAK_REPO=}" ;;
		'FLATPACK_REPO='*) FLATPACK_REPO="${item#*FLATPACK_REPO=}" ;;
		'SNAP='*) SNAP="${item#*SNAP=}" ;;
		'SNAP_CHANNEL='*) SNAP_CHANNEL="${item#*SNAP_CHANNEL=}" ;;
		'SNAP_CLASSIC='*) SNAP_CLASSIC="${item#*SNAP_CLASSIC=}" ;;
		'YUM='*) YUM="${item#*YUM=}" ;;
		'RPM='*) RPM="${item#*RPM=}" ;;
		'YUM_REPO='*) YUM_REPO="${item#*YUM_REPO=}" ;;
		'YUM_EVAL='*) YUM_EVAL="${item#*YUM_EVAL=}" ;;
		'APT='*) APT="${item#*APT=}" ;;
		'DEBIAN='*) DEBIAN="${item#*DEBIAN=}" ;;
		'APT_REPO='*) APT_REPO="${item#*APT_REPO=}" ;;
		'APT_KEY='*) APT_KEY="${item#*APT_KEY=}" ;;
		'APT_KEY_NAME='*) APT_KEY_NAME="${item#*APT_KEY_NAME=}" ;;
		'APT_EVAL='*) APT_EVAL="${item#*APT_EVAL=}" ;;
		'ALPINE='*) ALPINE="${item#*ALPINE=}" ;;
		'NIX='*) NIX="${item#*NIX=}" ;;
		'XBPS='*) XBPS="${item#*XBPS=}" ;;
		'VOID='*) VOID="${item#*VOID=}" ;;
		'EOPKG='*) EOPKG="${item#*EOPKG=}" ;;
		'SOLUS='*) SOLUS="${item#*SOLUS=}" ;;
		'EMERGE='*) EMERGE="${item#*EMERGE=}" ;;
		'EMERGE_EVAL='*) EMERGE_EVAL="${item#*EMERGE_EVAL=}" ;;
		'DNF='*) DNF="${item#*DNF=}" ;;
		'DNF_EVAL='*) DNF_EVAL="${item#*DNF_EVAL=}" ;;
		'DNF_COPR='*) DNF_COPR="${item#*DNF_COPR=}" ;;
		'DNF_REPO='*) DNF_REPO="${item#*DNF_REPO=}" ;;
		'ZYPPER='*) ZYPPER="${item#*ZYPPER=}" ;;
		'ZYPPER_EVAL='*) ZYPPER_EVAL="${item#*ZYPPER_EVAL=}" ;;
		'ZYPPER_REPO='*) ZYPPER_REPO="${item#*ZYPPER_REPO=}" ;;
		'PORT='*) PORT="${item#*PORT=}" ;;
		'CHOCO='*) CHOCO="${item#*CHOCO=}" ;;
		'SCOOP='*) SCOOP="${item#*SCOOP=}" ;;
		'WINGET='*) WINGET="${item#*WINGET=}" ;;
		'PKG='*) PKG="${item#*PKG=}" ;;
		'PKGUTIL='*) PKGUTIL="${item#*PKGUTIL=}" ;;
		'HUBER='*) HUBER="${item#*HUBER=}" ;;
		'GUIX='*) GUIX="${item#*GUIX=}" ;;
		'DPKG='*) DPKG="${item#*DPKG=}" ;;
		'DPKG_EVAL='*) DPKG_EVAL="${item#*DPKG_EVAL=}" ;;
		'DOAS='*) DOAS="${item#*DOAS=}" ;;
		'PKGADD='*) PKGADD="${item#*PKGADD=}" ;;
		'PKGIN='*) PKGIN="${item#*PKGIN=}" ;;
		'PKGMAN='*) PKGMAN="${item#*PKGMAN=}" ;;
		'STACK='*) STACK="${item#*STACK=}" ;;
		'CABAL='*) CABAL="${item#*CABAL=}" ;;
		'CONDA='*) CONDA="${item#*CONDA=}" ;;
		'CONDA_CHANNEL='*) CONDA_CHANNEL="${item#*CONDA_CHANNEL=}" ;;
		'NPM='*) NPM="${item#*NPM=}" ;;
		'NODE='*) NODE="${item#*NODE=}" ;;
		'NPM_EVAL='*) NPM_EVAL="${item#*NPM_EVAL=}" ;;
		'NPM_FORCE='*) NPM_FORCE="${item#*NPM_FORCE=}" ;;
		'GO='*) GO="${item#*GO=}" ;;
		'PIPX='*) PIPX="${item#*PIPX=}" ;;
		'PIP='*) PIP="${item#*PIP=}" ;;
		'PYTHON='*) PYTHON="${item#*PYTHON=}" ;;
		'PIP_EVAL='*) PIP_EVAL="${item#*PIP_EVAL=}" ;;
		'GEM='*) GEM="${item#*GEM=}" ;;
		'RUBY='*) RUBY="${item#*RUBY=}" ;;
		'GEM_EVAL='*) GEM_EVAL="${item#*GEM_EVAL=}" ;;
		'GEM_VERSION='*) GEM_VERSION="${item#*GEM_VERSION=}" ;;
		'CARGO='*) CARGO="${item#*CARGO=}" ;;
		'RUST='*) RUST="${item#*RUST=}" ;;
		'INSTALLER='*) INSTALLER="${item#*INSTALLER=}" ;;
		'INSTALLER_OPEN='*) INSTALLER_OPEN="${item#*INSTALLER_OPEN=}" ;;
		'DOWNLOAD='*) DOWNLOAD="${item#*DOWNLOAD=}" ;;
		'DOWNLOAD_FILENAME='*) DOWNLOAD_FILENAME="${item#*DOWNLOAD_FILENAME=}" ;;
		'DOWNLOAD_UNZIP_FORMAT='*) DOWNLOAD_UNZIP_FORMAT="${item#*DOWNLOAD_UNZIP_FORMAT=}" ;;
		'DOWNLOAD_UNZIP_FILTER='*) DOWNLOAD_UNZIP_FILTER="${item#*DOWNLOAD_UNZIP_FILTER=}" ;;
		'GITHUB_SLUG='*) GITHUB_SLUG="${item#*GITHUB_SLUG=}" ;;
		'GITHUB_RELEASE='*) GITHUB_RELEASE="${item#*GITHUB_RELEASE=}" ;;
		'GITHUB_ASSET_FILTER='*) GITHUB_ASSET_FILTER="${item#*GITHUB_ASSET_FILTER=}" ;;
		'GITHUB_UNZIP_FORMAT='*) GITHUB_UNZIP_FORMAT="${item#*GITHUB_UNZIP_FORMAT=}" ;;
		'GITHUB_UNZIP_FILTER='*) GITHUB_UNZIP_FILTER="${item#*GITHUB_UNZIP_FILTER=}" ;;
		'GITHUB_FILENAME='*) GITHUB_FILENAME="${item#*GITHUB_FILENAME=}" ;;
		*) ;; # passively ignore, could be custom arg, such as --paths for setup-util-plex
		esac
	done

	# ensure name fallback
	if test -z "$name" -a -n "$cli"; then
		name="$cli"
	fi

	# ensure order
	local temp_order installer inject_installer
	if test "${#order[@]}" -eq 0; then
		order=("${installers[@]}")
	else
		# custom order, handle ...
		# so [snap ...] means snap first, then everything else, whereas [... apt] means everyting then apt
		# as such, the specified installers need to be trimmed from the ... substitution
		# @todo this will currently hard fail if there is two ... occurences
		temp_order=()
		for installer in "${order[@]}"; do
			if test "$installer" = '...'; then
				for inject_installer in "${installers[@]}"; do
					if is-needle "$inject_installer" "${order[@]}"; then
						continue
					else
						temp_order+=("$inject_installer")
					fi
				done
			else
				temp_order+=("$installer")
			fi
		done
		order=("${temp_order[@]}")
	fi

	# =====================================
	# Process

	# prepare fallbacks, for when the package could be installed, but requires the package system to be installed first
	# which will be used, if none of the package systems were present, as such proceed in order of preference for installation of package systems
	local fallbacks=()

	# check if necessary
	if test -n "$cli"; then
		if command-missing "$cli"; then
			echo-style \
				--h3="The [$name] utility does not appear to be installed because [$cli] is missing. Installing automatically... ⏲"
		elif test "$upgrade" = 'yes'; then
			echo-style \
				--h3="The [$name] utility is already installed because [$cli] is present." $'\n' \
				--h3="However, it has been marked for upgrade. Upgrading... ⏲"
		elif test "$optional" != 'yes' && ! command-working "$cli"; then
			# only do a working check, if it is required, as otherwise too fragile
			echo-style \
				--h3="The [$name] utility does not appear to be installed correctly because [$cli] is misbehaving. Reinstalling automatically... ⏲"
		else
			if test "$quiet" != 'yes'; then
				echo-style \
					--g3="The [$name] utility is already installed because [$cli] is present. All good. ✅"
			fi
			return 0
		fi
	fi

	# confirm if necessary
	if test "$confirm" = 'yes'; then
		if ! confirm-positive --ppid=$$ -- "Do you want to install the [$name] utility?"; then
			return 2 # error exit code so that things that depend on this abort
		fi
	fi

	# log helpers
	function won {
		local method="$1"
		echo-style --g3="The [$name] utility is now installed via [$method]. ✅"
	}
	function lost {
		# log the failure
		echo-style --e3="The [$name] utility was unable to be installed. ❌"

		# debug the failure?
		if test "$name" = 'unnamed'; then
			if test "$quiet" != 'yes' && confirm-negative --ppid=$$ -- "Do you want to output the environment variables to determine what it was?"; then
				env | sort
			fi
			sleep 5
		fi

		# ignore the failure?
		if test "$optional" != 'no'; then
			echo-style --e3="Anyway, [$name] has been marked as optional, so it is up to you to figure this out later."
			return 0
		fi

		# propagate the failure
		return 1
	}

	# =====================================
	# Installers

	# brew / Homebrew / macOS
	function do_brew {
		local cmd=() pkgs=() pkg="${BREW:-"${HOMEBREW-}"}"

		# check applicabile
		if test -n "$pkg"; then
			# check possible
			if ! is-brew; then
				# not possible, but can be fallen back to if mac
				if is-mac; then
					fallbacks+=('brew')
				fi
				return 1
			fi

			# construct command
			cmd+=('brew')
			if test "$upgrade" = 'yes'; then
				cmd+=('upgrade')
			else
				cmd+=('install')
			fi
			if test "$force" = 'yes'; then
				cmd+=('--force')
			fi
			if test "$quiet" != 'no'; then
				cmd+=('--quiet')
			fi

			# support multiple pkgs inside BREW
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# install, the `brew upgrade` in `setup-mac-brew` will handle upgrades
			eval-helper --quiet -- "${cmd[@]}" "${pkgs[@]}"
		else
			return 1
		fi
	}
	function do_brew_fallback {
		setup-mac-brew
		source "$DOROTHY/sources/environment.sh"
		do_brew "$@"
	}

	# brew / Homebrew Casks / macOS
	function do_cask {
		local cmd=() pkgs=() pkg="${CASK-}"

		# check applicable
		if test -n "$pkg"; then
			# check possible
			if ! is-brew; then
				# not possible, but can be fallen back to if mac
				if is-mac; then
					fallbacks+=('cask')
				fi
				return 1
			fi

			# construct command
			cmd+=('brew')
			if test "$upgrade" = 'yes'; then
				cmd+=('upgrade')
			else
				cmd+=('install')
			fi
			if test "$force" = 'yes'; then
				cmd+=('--force')
			fi
			if test "$quiet" != 'no'; then
				cmd+=('--quiet')
			fi
			cmd+=('--cask')

			# support multiple pkgs inside CASK
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# install
			eval-helper --quiet -- "${cmd[@]}" "${pkgs[@]}"
		else
			# not applicable
			return 1
		fi
	}
	function do_cask_fallback {
		setup-mac-brew
		source "$DOROTHY/sources/environment.sh"
		do_cask "$@"
	}

	# pacman / Arch Linux / Manjaro
	function do_pacman {
		local cmd=() pkg="${PACMAN-}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists pacman; then
			# package case
			# --needed: do not reinstall up to date packages
			# --noconfirm: do not ask for any confirmation
			cmd+=('sudo' 'pacman' '-S' '--needed' '--noconfirm')
			if test "$quiet" != 'no'; then
				# -q, --quiet: show less information for query and search
				cmd+=('--quiet')
			fi
			eval-helper --quiet -- "${cmd[@]}" "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# yay / AUR / Arch Linux
	# https://github.com/Jguer/yay
	function do_yay {
		local pkg="${YAY:-"${AUR:-"${ARCH-}"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists yay; then
			# package case
			eval-helper --quiet -- yay -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# paru / AUR / Arch Linux
	# https://itsfoss.com/paru-aur-helper/
	function do_paru {
		local pkg="${PARU:-"${AUR:-"${ARCH-}"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists paru; then
			# package case
			eval-helper --quiet -- paru -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pakku / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	function do_pakku {
		local pkg="${PAKKU:-"${AUR:-"${ARCH-}"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists pakku; then
			# package case
			eval-helper --quiet -- pakku -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# aurutils / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	function do_aurutils {
		local pkg="${AURUTILS:-"${AUR:-"${ARCH-}"}"}"

		# check applicabile and possible
		if test -n "$pkg" && command-exists aurutils; then
			# package case
			eval-helper --quiet -- aurutils -Sy "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pamac / AUR / Arch Linux
	# https://itsfoss.com/best-aur-helpers/
	function do_pamac {
		local pkg="${PAMAC:-"${AUR:-"${ARCH-}"}"}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing pamac; then
				fallbacks+=('pamac')
				return 1
			fi

			# package case
			eval-helper --quiet -- pamac install --no-confirm "$pkg"
		else
			# not applicable
			return 1
		fi
	}
	function do_pamac_fallback {
		setup-util-pamac
		do_pamac "$@"
	}

	# flatpak / Arch Linux / Manjaro
	function do_flatpak {
		# accomodate flatpak typos
		local pkg="${FLATPAK:-"${FLATPACK-}"}" repo="${FLATPAK_REPO:-"${FLATPACK_REPO:-"flathub"}"}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing flatpak; then
				fallbacks+=('flatpak')
				return 1
			fi

			# package case
			eval-helper --quiet -- flatpak install "$repo" "$pkg"
		else
			# not applicable
			return 1
		fi
	}
	function do_flatpak_fallback {
		setup-util-flatpak
		do_flatpak "$@"
	}

	# snap / Snap Craft / Ubuntu
	function do_snap {
		local cmd=() pkgs=() pkg="${SNAP-}" channel="${SNAP_CHANNEL-}" classic="${SNAP_CLASSIC-}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing snap; then
				fallbacks+=('snap')
				return 1
			fi

			# support multiple pkgs inside SNAP
			cmd=('sudo' 'snap' 'install')
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# optional `--classic` if `SNAP_CLASSIC` affirmative
			if is-affirmative "$classic"; then
				cmd+=('--classic')
			fi

			# optional `--channel=...` if `SNAP_CHANNEL` is present
			if test -n "$channel"; then
				cmd+=("--channel=$channel")
			fi

			# package case
			eval-helper --quiet -- "${cmd[@]}" "${pkgs[@]}"
			# ^ needs sudo, otherwise: error: access denied (try with sudo)
		else
			# not applicable
			return 1
		fi
	}
	function do_snap_fallback {
		setup-util-snap
		do_snap "$@"
	}

	# yum / rpm / RedHat / Fedora / CentOS / etc
	function do_yum {
		# accomodate rpm fallback
		local pkg="${YUM:-"${RPM-}"}" repo="${YUM_REPO-}" __eval="${YUM_EVAL-}"

		# check applicabile
		if test -n "$pkg" -o -n "$__eval"; then
			# check relevancy
			if ! command-exists yum; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# prepare YUM with YUM_REPO if relevant
				if test -n "$repo"; then
					cd /etc/yum.repos.d/ || return 1
					down "$repo"
				fi

				# install
				eval-helper --quiet -- sudo yum install -y "$pkg"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# apt / Ubuntu / Debian / Linux Mint / elementary OS / etc
	# can also be used for install .deb files
	# aptitude is deprecated, apt won
	# https://wiki.debian.org/Apt
	function do_apt_key_fetch {
		local key="$1"
		if [[ $key == *'.asc' ]]; then
			# .asc files
			fetch "$key" | gpg --dearmor
		else
			# .key and unknown files
			fetch "$key"
		fi
	}
	function do_apt {
		local pkgs=() keyring='' pkg="${APT:-"${DEBIAN-}"}" repo="${APT_REPO-}" key="${APT_KEY-}" key_name="${APT_KEY_NAME-}" __eval="${APT_EVAL-}"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! is-apt; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# support multiple pkgs inside APT
				mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

				# prepare APT with APT_KEY
				if test -n "$key"; then
					# attempt to ensure APT_KEY_NAME if not provided
					if test -z "$key_name"; then
						if [[ $pkg == *' '* ]]; then
							cat <<-EOF >/dev/stderr
								"$(echo-style --error="If APT has multiple packages, then APT_KEY_NAME must be specified.")
								APT: $pkg
								APT_KEY: $key
							EOF
							return 1
						fi
						key_name="$pkg"
					fi

					# Deprecated technique is: fetch ... | sudo apt-key add -
					# https://blog.jak-linux.org/2021/06/20/migrating-away-apt-key/
					# https://packagecloud.io/blog/what-does-it-mean-to-add-a-repository-to-my-sources/#strongaddaptrepositorystrong
					# https://linuxize.com/post/how-to-add-apt-repository-in-ubuntu/
					# https://www.techrepublic.com/article/how-to-add-an-openpgp-repository-key-now-that-apt-key-is-deprecated/

					# Modern technique is below:
					# https://stackoverflow.com/a/69015383/130638
					keyring="/etc/apt/trusted.gpg.d/$key_name.gpg"
					do_apt_key_fetch "$key" | sudo gpg \
						--import --no-default-keyring \
						--keyring "gnupg-ring:$keyring"
				fi

				# prepare APT with APT_REPO
				if test -n "$repo"; then
					# replae key
					repo="${repo/"{KEY}"/"$keyring"}"
					# replace arch
					repo="${repo/"{ARCH}"/"$(
						dpkg --print-architecture
					)"}"
					# replace release
					repo="${repo/"{RELEASE}"/"$(
						lsb_release --codename --short
					)"}"
					# add the repo
					sudo apt-add-repository -y "$repo"
				fi

				# ensure that the package can be found, and that it will be the latest
				# initial installations may not have a package index yet, or it may be outdated
				eval-helper --quiet -- sudo apt-get update

				# install
				eval-helper --quiet -- sudo apt-get install -y --fix-broken "${pkgs[@]}"
				# use `apt-get`, as using `apt` produces this warning on Ubuntu 20.04.3 LTS
				# WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
			fi
		else
			# not applicable
			return 1
		fi
	}

	# apk / Alpine Linux
	function do_apk {
		local pkgs=() pkg="${APK:-"${ALPINE-}"}"

		# check applicable and possible
		if test -n "$pkg" && command-exists apk; then
			# support multiple pkgs inside APK
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# install
			eval-helper --quiet -- apk add "${pkgs[@]}"
		else
			# not needed
			return 1
		fi
	}

	# nix
	function do_nix {
		local pkg="${NIX-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists nix-env; then
			eval-helper --quiet -- nix-env -iA "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# xbps / Void Linux
	function do_xbps {
		local pkg="${XBPS:-"${VOID-}"}"

		# check applicable and possible
		if test -n "$pkg" && command-exists xbps-install; then
			eval-helper --quiet -- xbps-install -S "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# eopkg / Solus
	function do_eopkg {
		local pkg="${EOPKG:-"${SOLUS-}"}"

		# check applicable and possible
		if test -n "$pkg" && command-exists eopkg; then
			eval-helper --quiet -- sudo eopkg it "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# emerge / GURU / Gentoo Linux
	function do_emerge {
		local pkg="${EMERGE-}" __eval="${EMERGE_EVAL-}"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists emerge; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				eval-helper --quiet -- sudo emerge -av "$pkg"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# dnf / COPR / Fedora / CentOS / RHEL
	function do_dnf {
		local pkg="${DNF-}" __eval="${DNF_EVAL-}" copr="${DNF_COPR-}" repo="${DNF_REPO-}"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists dnf; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# prepare DNF with DNF_COPR
				if test -n "$copr"; then
					sudo dnf copr enable -y "$copr"
				fi

				# prepare DNF with DNF_REPO
				if test -n "$repo"; then
					sudo dnf config-manager -y --add-repo "$repo"
				fi

				# install
				eval-helper --quiet -- sudo dnf install -y "$pkg"
			fi
		else
			return 1
		fi
	}

	# zypper / openSUSE / SLES
	# zypper needs sudo
	function do_zypper {
		local pkg="${ZYPPER-}" __eval="${ZYPPER_EVAL-}" repo="${ZYPPER_REPO-}"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists zypper; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# prepare ZYPPER with ZYPPER_REPO
				if test -n "$__eval"; then
					sudo zypper addrepo "$__eval"
					sudo zypper refresh
				fi

				# install
				eval-helper --quiet -- sudo zypper install "$pkg"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# port / MacPorts
	function do_port {
		local pkg="${PORT-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists port; then
			eval-helper --quiet -- sudo port install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# choco / Chocolatey / Windows
	function do_choco {
		local pkg="${CHOCO-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists choco; then
			eval-helper --quiet -- choco install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# scoop / Windows
	function do_scoop {
		local pkg="${SCOOP-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists scoop; then
			eval-helper --quiet -- scoop install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# winget / Windows Package Manager Client
	function do_winget {
		local pkg="${WINGET-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists winget; then
			eval-helper --quiet -- winget install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkg / FreeBSD / Termux
	function do_pkg {
		local pkg="${PKG-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkg; then
			eval-helper --quiet -- pkg install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkgutil / Solaris 10+, Sparc and x86.
	function do_pkgutil {
		local pkg="${PKGUTIL-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkgutil; then
			eval-helper --quiet -- pkgutil -i "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# huber
	function do_huber {
		local pkg="${HUBER-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists huber; then
			eval-helper --quiet -- huber install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# guix
	function do_guix {
		local pkg="${GUIX-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists guix; then
			eval-helper --quiet -- guix package -i "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# dpkg / Debian / Ubuntu / Linux Mint / elementary OS / etc
	# used for installing .deb files
	function do_dpkg {
		local pkg="${DPKG-}" __eval="${DPKG_EVAL-}"

		# check applicable
		if test -n "$pkg" -o -n "$__eval"; then
			# check possible
			if ! command-exists dpkg; then
				# not possible
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				eval-helper --quiet -- sudo dpkg --install "$pkg"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# doas / Solaris
	function do_doas {
		local pkg="${DOAS-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists doas; then
			eval-helper --quiet -- doas pkg_add "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkg_add / OpenBSD
	function do_pkg {
		local pkg="${PKGADD-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkg_add; then
			eval-helper --quiet -- pkg_add "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkgin/ NetBSD
	function do_pkgin {
		local pkg="${PKGIN-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkgin; then
			eval-helper --quiet -- pkgin install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# pkgman / Haiku
	function do_pkgman {
		local pkg="${PKGMAN-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists pkgman; then
			eval-helper --quiet -- pkgman install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# stack
	function do_stack {
		local pkg="${STACK-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists stack; then
			stack update
			eval-helper --quiet -- stack install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# cabal
	function do_cabal {
		local pkg="${CABAL-}"

		# check applicable and possible
		if test -n "$pkg" && command-exists cabal; then
			cabal update
			eval-helper --quiet -- cabal install "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# conda
	function do_conda {
		local pkg="${CONDA-}" channel="${CONDA_CHANNEL-}"

		# check applicable and possible
		# require channel to be defined, as CONDA is always present on github CI
		if test -n "$pkg" -a "$channel" && command-exists conda; then
			eval-helper --quiet -- conda install -c "$channel" "$pkg"
		else
			# not needed
			return 1
		fi
	}

	# npm / Node.js
	function do_npm {
		local cmd=() pkgs=() pkg="${NPM:-"${NODE-}"}" __eval="${NPM_EVAL-}" force="${NPM_FORCE-}"

		if test -n "$pkg" -o -n "$__eval"; then
			# fallback case
			if command-missing npm; then
				fallbacks+=('npm')
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# support multiple pkgs inside NPM
				cmd=('npm' 'install' '--global')
				mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

				# optional --force
				if is-affirmative "$force"; then
					cmd+=('--force')
				fi

				# install
				eval-helper --quiet -- "${cmd[@]}" "${pkgs[@]}"
			fi
		else
			# not applicable
			return 1
		fi
	}
	function do_npm_fallback {
		setup-node
		source "$DOROTHY/sources/environment.sh"
		set +e # nvm prevents strict from working: .nvm/nvm.sh: line 1966: TMPDIR: unbound variable
		source "$DOROTHY/sources/nvm.sh"
		do_npm "$@"
	}

	# go
	function do_go {
		local pkg="${GO-}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing go; then
				fallbacks+=('go')
				return 1
			fi

			# add version if not there
			if [[ $pkg != *'@'* ]]; then
				pkg="${pkg}@latest"
			fi

			# package case
			eval-helper --quiet -- go install -v "$pkg"
		else
			# not applicable
			return 1
		fi
	}
	function do_go_fallback {
		setup-go
		source "$DOROTHY/sources/environment.sh"
		do_go "$@"
	}

	# pip / Python
	function pip_helper {
		# Use the correct [pip] executable for the user's environment, as there may be many or multiple installed, such as one for Python v2 and one for Python v3.
		if command-exists pip; then
			pip "$@"
		elif python -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists pip3; then
			pip3 "$@"
		elif python3 -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists pip2; then
			pip2 "$@"
		elif python2 -m pip --version &>/dev/null; then
			python -m pip "$@"
		elif command-exists /usr/local/bin/pip; then
			/usr/local/bin/pip "$@"
		elif test -n "${HOMEBREW_PREFIX-}" -a -x "${HOMEBREW_PREFIX-}/bin/pip"; then
			"${HOMEBREW_PREFIX}/bin/pip" "$@"
		else
			echo-style --error="[pip] nor its variations were found" >/dev/stderr
			return 1
		fi
	}
	function do_pip {
		local pkgs=() pkg="${PIP:-"${PYTHON-}"}" __eval="${PIP_EVAL-}"

		if test -n "$pkg" -o -n "$__eval"; then
			# fallback case
			if ! pip_helper --version &>/dev/null; then
				fallbacks+=('pip')
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				# support multiple pkgs inside PIP
				mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

				# install
				eval-helper --quiet -- pip_helper install --user --upgrade --force-reinstall --no-warn-script-location "${pkgs[@]}"
			fi
		else
			# not applicable
			return 1
		fi
	}
	function do_pip_fallback {
		setup-python
		source "$DOROTHY/sources/environment.sh"
		do_pip "$@"
	}

	# pipx / Python
	function do_pipx {
		local pkgs=() pkg="${PIPX:-"${PYTHON-}"}"

		# check applicablity
		if test -n "$pkg"; then
			# fallback case
			if command-missing pipx; then
				fallbacks+=('pipx')
				return 1
			fi

			# support multiple pkgs inside PIPX
			mapfile -t pkgs < <(echo-split ' ' -- "$pkg")

			# package case
			eval-helper --quiet -- pipx install "${pkgs[@]}"
		else
			# not applicable
			return 1
		fi
	}
	function do_pipx_fallback {
		if ! pip_helper --version &>/dev/null; then
			setup-python
		fi
		setup-util-pipx
		source "$DOROTHY/sources/environment.sh"
		do_pipx "$@"
	}

	# gem / Ruby
	# we use --user-install because of:
	# https://github.com/ffi/ffi/issues/631
	function do_gem {
		local pkg="${GEM:-"${RUBY-}"}" __eval="${GEM_EVAL-}" version="${GEM_VERSION-}"

		# check relevancy
		if test -n "$pkg" -o -n "$__eval"; then
			# check requisites
			if command-missing gem; then
				fallbacks+=('gem')
				return 1
			fi

			# eval case
			if test -n "$__eval"; then
				eval "$__eval"
				return "$?"
			fi

			# package case
			if test -n "$pkg"; then
				gem uninstall "$pkg" -axI &>/dev/null
				if test -n "$version"; then
					eval-helper --quiet -- gem install "$pkg" --version "$version" --user-install --no-document
				else
					eval-helper --quiet -- gem install "$pkg" --user-install --no-document
				fi
			fi
		else
			# not applicable
			return 1
		fi
	}
	function do_gem_fallback {
		setup-ruby
		source "$DOROTHY/sources/environment.sh"
		do_gem "$@"
	}

	# cargo / Crates.io / Rust
	function do_cargo {
		local pkg="${CARGO:-"${RUST-}"}"

		# check applicabile
		if test -n "$pkg"; then
			# fallback case
			if command-missing cargo; then
				fallbacks+=('cargo')
				return 1
			fi

			# package case
			if test "$quiet" != 'yes'; then
				log-performance
			fi
			eval-helper --quiet -- cargo install "$pkg"
		else
			# not applicable
			return 1
		fi
	}
	function do_cargo_fallback {
		setup-rust
		source "$DOROTHY/sources/environment.sh"
		do_cargo "$@"
	}

	# installer
	function do_installer {
		local file file_or_url="${INSTALLER-}" __open="${INSTALLER_OPEN-}"

		# check applicabile
		if test -n "$file_or_url"; then
			# check if it is local, or remote
			if test -e "$file_or_url"; then
				file="$file_or_url"
			else
				# it is remote
				# download it to a temporary location and use that
				file="$(
					fs-temp \
						--directory='setup-util' \
						--directory="$name" \
						--file
				)"
				down "$file_or_url" --path="$file"
			fi
			# ensure it is executable, then open or run it
			chmod +x "$file"
			if test "$__open" = 'yes'; then
				open "$file"
			else
				# SETUP_UTIL=yes so the cmd knows it is running inside SETUP_UTIL
				# Undo any inherited FORCE/UPGRADE=true, such that the cmd doesn't re-run itself
				eval-helper --quiet -- env SETUP_UTIL=yes UPGRADE= FORCE= "$file"
			fi
		else
			# not applicable
			return 1
		fi
	}

	# github
	function do_github {
		local slug="${GITHUB_SLUG-}" filename="${GITHUB_FILENAME-}" release="${GITHUB_RELEASE-}" asset_filter="${GITHUB_ASSET_FILTER-}" unzip_format="${GITHUB_UNZIP_FORMAT-}" unzip_filter="${GITHUB_UNZIP_FILTER-}"

		# check applicabile
		if test -n "$slug"; then
			# require filename
			if test -z "$filename"; then
				echo-style --error="GITHUB requires GITHUB_FILENAME"
				return 1
			fi

			# prepare
			mkdir -p "$XDG_BIN_HOME"

			# download
			github-download \
				--slug="$slug" \
				--release="$release" \
				--asset-filter="$asset_filter" \
				--unzip-format="$unzip_format" \
				--unzip-filter="$unzip_filter" \
				--path="$XDG_BIN_HOME/$filename"

			# adjust
			fs-own --permissions='+x' "$XDG_BIN_HOME/$filename"

			# verify
			if ! command-working "$XDG_BIN_HOME/$filename"; then
				echo-style --error="GITHUB installed, however failed to verify."
				return 1
			fi
		else
			# not applicable
			return 1
		fi
	}

	# download
	function do_download {
		local download="${DOWNLOAD-}" filename="${DOWNLOAD_FILENAME-}" unzip_format="${DOWNLOAD_UNZIP_FORMAT-}" unzip_filter="${DOWNLOAD_UNZIP_FILTER-}"

		# check applicabile
		if test -n "$download"; then
			# require filename
			if test -z "$filename"; then
				echo-style --error="DOWNLOAD requires DOWNLOAD_FILENAME"
				return 1
			fi

			# prepare
			mkdir -p "$XDG_BIN_HOME"

			# download
			down "$download" \
				--unzip-format="$unzip_format" \
				--unzip-filter="$unzip_filter" \
				--path="$XDG_BIN_HOME/$filename"

			# adjust
			fs-own --permissions='+x' "$XDG_BIN_HOME/$filename"

			# verify
			if ! command-working "$XDG_BIN_HOME/$filename"; then
				echo-style --error="DOWNLOAD installed, however failed to verify."
				return 1
			fi
		else
			# not applicable
			return 1
		fi
	}

	# aur
	function do_aur {
		do_yay
		do_pakku
		do_paru
		do_aurutils
		do_pamac
	}

	# =====================================
	# Action

	local installer

	# cycle through the order
	for installer in "${order[@]}"; do
		# sanity check
		if test -z "$installer"; then
			echo-style --error="an empty order argument was provided"
			echo-verbose "${order[@]}"
			return 22 # Invalid argument
		fi
		# # this installer was disabled, ignore
		# if test -z "$installer"; then
		# 	continue
		# fi
		# attempt installation
		if "do_${installer}"; then
			won "$installer"
			return 0
		fi
	done

	# fallback for failed packages which are missing their package system
	if test "${#fallbacks[@]}" -ne 0; then
		for installer in "${fallbacks[@]}"; do
			if "do_${installer}_fallback"; then
				won "$installer"
				return 0
			fi
		done
	fi

	# failure
	lost
	return "$?"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup-util "$@"
fi
