#!/usr/bin/env bash
# shellcheck disable=SC2059
# ^ [echo -en] doesn't work with escape codes on bash v3, [printf ...] does
source "$DOROTHY/sources/strict.bash"

function confirm() (
	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			USAGE:
			confirm --ppid=\$\$ [...options] -- <question> ...[detail]

			OPTIONS:
			--mode=<bool|positive|negative|confirm>
			    [bool] mode forces a positive or negative confirmation, with no default.
			    [positive] mode defaults to a positive confirmation.
			    [negative] mode defaults to a negative confirmation.
			    [confirm] mode forces a confirmation, with no default.

			--timeout=<timeout>
			    Specify the timeout in seconds.
			    Under <negative> mode, defaults to 60 seconds (one minute) before defaulting to a negative confirmation.
			    Under <positive> mode, defaults to 60 seconds (one minute) before defaulting to a positive confirmation.
			    Under other modes, defaults to 3600 seconds (one hour) before abortion occurs.

			--yes=<OK>
			    What to display to the user for positive confirmations, defaults to "OK".

			--no=<CANCEL>
			    What to display to the user for negative confirmations, defaults to "CANCEL".

			--abort=<ABORT>
			    What to display to the user for aborted confirmations, defaults to "ABORT".

			--ppid=<ppid>
			    Specifies the parent process ID to also terminate upon abortion.
			    In bourne shells this is specified like so [--ppid=\$\$]
			    This is necessary because the typical usage of [if confirm ...; then ...; else ...; fi]
			    will only catch positive and negative confirmations, but not abortion cases,
			    as such abortions would otherwise be registered as negative cases.
			    Providing the parent process ID allows the abortion to propagate to the parent,
			    allowing the intended abortion behaviour to propagate.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# prepare
	local item question_parts=() mode='confirm' timeout='3600' yes='OK' no='CANCEL' abort='ABORT' ppid=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--mode='*)
			mode="${item:7}" # bool/positive/negative/confirm
			if test "$mode" = 'positive' -o "$mode" = 'negative'; then
				timeout='60' # one minute
				yes='YES'
				no='NO'
			elif test "$mode" = 'bool'; then
				yes='YES'
				no='NO'
			fi
			;;
		'--timeout='*) timeout="${item:10}" ;;
		'--yes='*) yes="${item:6}" ;;
		'--no='*) no="${item:5}" ;;
		'--abort='*) abort="${item:8}" ;;
		'--ppid='*) ppid="${item:7}" ;; # alias for term
		'--')
			question_parts+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*) help "An unrecognised argument was provided: $item" ;;
		esac
	done

	# requirements
	if test -z "$ppid"; then
		help '--ppid=$$ is necessary'
	fi

	# =====================================
	# Helpers

	# used to process the input
	function confirmer {
		local ec answer

		# ask and timeout
		ec=0 && answer="$(read-key --timeout="$timeout")" || ec="$?"

		# process
		if test "$mode" = 'positive'; then
			# positive
			if test "$ec" -eq 62; then
				return 0 # timeout
			elif test "$ec" -ne 0; then
				return "$ec" # failure
			fi
			ec=0 && is-affirmative "$answer" || ec="$?"
			if test "$ec" -lt 2; then
				return "$ec"
			elif test "$answer" = 'enter' -o "$answer" = 'space'; then
				return 0
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # Operation canceled
			fi

		elif test "$mode" = 'negative'; then
			# negative
			if test "$ec" -eq 62; then
				return 1 # timeout
			elif test "$ec" -ne 0; then
				return "$ec" # failure
			fi
			ec=0 && is-affirmative "$answer" || ec="$?"
			if test "$ec" -lt 2; then
				return "$ec"
			elif test "$answer" = 'enter' -o "$answer" = 'space'; then
				return 1
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # Operation canceled
			fi

		elif test "$mode" = 'bool'; then
			# bool
			if test "$ec" -ne 0; then
				return "$ec" # timeout and failure
			fi
			ec=0 && is-affirmative "$answer" || ec="$?"
			if test "$ec" -lt 2; then
				return "$ec"
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # Operation canceled
			fi

		elif test "$mode" = 'confirm'; then
			# confirm
			if test "$ec" -ne 0; then
				return "$ec" # timeout and failure
			fi
			ec=0 && is-affirmative "$answer" || ec="$?"
			if test "$ec" -lt 2; then
				return "$ec"
			elif test "$answer" = 'enter' -o "$answer" = 'space'; then
				return 0
			elif test "$answer" = 'escape' -o "$answer" = 'q'; then
				return 125 # Operation canceled
			fi

		else
			# unknown
			help "An invalid <mode> was provided: $mode"
		fi

		# try again, and erase any leaked characters
		printf "\e[${hx}G\e[K"
		confirmer "$@"
		return "$?" # return with the above on success and failure
	}

	# =====================================
	# Question

	local question_first_part="${question_parts[0]} " # this is stored for the finale
	local question_parts_total="${#question_parts[@]}"
	local question_parts_last="$((question_parts_total - 1))"
	local index header lines=0 result=0 _hx=''
	header="$(mktemp)"

	# update the first question part
	if test "$mode" = 'positive'; then
		question_parts[0]+=" $(echo-style --blink='(' --blink+green+bold='Y' --blink='/n)')"
	elif test "$mode" = 'negative'; then
		question_parts[0]+=" $(echo-style --blink='(y/' --blink+red+bold='N' --blink=')')"
	elif test "$mode" = 'bool'; then
		question_parts[0]+=" $(echo-style --blink='(y/n)')"
	elif test "$mode" = 'confirm'; then
		question_parts[0]+=" $(echo-style --blink='(CONFIRM)')"
	else
		help "An invalid <mode> was provided: $mode"
	fi

	# output the question parts
	# saving the cursor position of the first line
	# and outputting a newline beteen all lines, except the last, which should not have a trailing line
	for ((index = 0; index < "$question_parts_total"; index++)); do
		echo -n "${question_parts[index]} " | tee -a "$header"
		if test "$index" -eq 0; then
			# read cursor x y, discard y, set hx to y
			IFS='[;' read -srd R -p $'\e[6n' _ _ hx
		fi
		if test "$index" -ne "$question_parts_last"; then
			echo | tee -a "$header"
		fi
	done

	# move the cursor
	if test "$question_parts_total" -ne 0; then
		# reposition the cursor, to after the options in the first part
		lines="$(echo-count-lines --no-inline <"$header")"
		# move these lines up
		if test "$lines" -ne 0; then
			printf "\e[${lines}F"
		fi
		# move to the hx column
		printf "\e[${hx}G"
	fi

	# handle terminations
	function failure {
		result="$?"
	}
	function finish {
		# in case we were called naturally, erase the listen
		trap - EXIT
		# make sure to erase question, as ctrl+c buggers everything
		printf '\e[G\e[J'
		# output the finale
		if test "$result" -eq 0; then
			echo-style "$question_first_part" --green+bold="$yes"
		elif test "$result" -eq 1; then
			echo-style "$question_first_part" --red+bold="$no"
		else
			echo-style "$question_first_part" --red+bold="$abort"
			if test -n "$ppid"; then
				# kill "-$ppid" ...
				# ^ fails because 130 isn't supported
				# kill -n ... ...
				# kill "-$(kill -l "$ppid")" ...
				# ^ works but isn't serious enough to cause the termination
				# "$(ps -p $$ -o ppid=)"
				# ^ doesn't work, as is different pid than manual
				kill "$ppid"
			fi
		fi
	}
	trap failure SIGINT SIGTERM
	trap finish EXIT

	# read and handle answer
	confirmer || result="$?"
	finish
	exit "$result" # exit with the result

	# @todo
	# an alternative implementation could be a new line like this at the end, with ENTER and ESCAPE and SPACE as the correct outputs
	# echo-style --blink='Press: ' --blink+green+bold='y ' --blink='for ' --blink+green='YES' --blink=', ' --blink+red+bold='n ' --blink='for ' --blink+red='NO' --blink=', ' --blink+bold='ENTER '  --blink='for ' --blink+red='NO'

	# using \e[s (save) and \e[u (restore) for ctrl+c handling did not work
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	confirm "$@"
fi
