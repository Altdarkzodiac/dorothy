#!/usr/bin/env bash

# https://docs.docker.com/engine/install/fedora/
# https://docs.docker.com/engine/install/fedora/#install-using-the-convenience-script
# https://docs.docker.com/engine/install/ubuntu/
# https://docs.docker.com/engine/install/ubuntu/#install-using-the-convenience-script
# https://docs.docker.com/engine/install/linux-postinstall/
# don't go rootless, is too complicated

# for some reason https://docs.docker.com/engine/install/linux-postinstall/ recommends
#	sudo-helper -- groupadd docker || :
#	sudo-helper -- usermod -aG docker "$USER"
# yet https://snapcraft.io/docker recommends
#	sudo-helper -- addgroup --system docker || :
#	sudo-helper -- adduser "$USER" docker || :
# we will prcoeed with the official instructions

# old ways
#	sudo-helper -- service docker restart
# new ways are what are implemented

# @todo experiemnt with using `newgrp docker` instead to workaround need for postinstall

function setup-util-docker() (
	source "$DOROTHY/sources/strict.bash"
	source "$(which eval-helper)"

	# =====================================
	# Arguments

	# help
	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Sets up Docker according to the recommended setup for your platform.

			USAGE:
			setup-util-docker

			OPTIONS:
			--paths
			    If specified, output the paths used by syncthing; useful for restoring backups.

			--service
			    If specified, output the service name.

			...
			    All other options are forwarded to $(echo-style --code='setup-util').
		EOF
		return 22 # Invalid argument
	}

	# process
	local item action='install' util=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--paths') action='paths' ;;
		'--service') action='service' ;;
		'--install') action='install' ;;
		'--uninstall') action='uninstall' ;;
		'--postinstall') action='postinstall' ;;
		'--debug') action='debug' ;;
		'--check') action='check' ;;
		'--action='*) action="${item#*--action=}" ;;
		*) util+=("$item") ;;
		esac
	done

	# ensure action inside util
	util+=("--action=$action")

	# =====================================
	# Preparation

	local service_name='docker'
	local service_user="$USER"
	local service_group='docker'
	local service_attach_users=("$service_user")
	# local service_attach_groups=("$service_group")
	local service_config_paths=(
		"$HOME/.docker"
	)
	local service_uninstall_paths=(
		/etc/apparmor.d/docker
		/etc/docker
		/usr/bin/docker-compose
		/var/lib/containerd
		/var/lib/docker
		/var/run/docker.sock
	)

	# =====================================
	# Simple Actions

	if test "$action" = 'paths'; then
		echo-lines "${service_config_paths[@]}"
		return 0
	elif test "$action" = 'service'; then
		echo "$service_name"
		return 0
	fi

	# =====================================
	# Setup Utility

	function check_group {
		is-group "$service_group"
	}
	function check_user_in_group {
		is-user-in-group --user="$service_user" --group="$service_group"
	}
	function delete_service_group {
		# remove the group from all users and the system, better than delgroup which is more focused only on the current user
		sudo-helper -- groupdel "$service_group"
	}
	function add_service_group {
		# add a group to the system, better than addgroup which is more focused only on the current user
		sudo-helper -- groupadd "$service_group"
	}
	function add_service_users_to_service_group {
		local user
		for user in "${service_attach_users[@]}"; do
			# attach the user to the group
			sudo-helper -- usermod -aG "$service_group" "$user"
		done
	}
	function add_permissions_to_config {
		mkdir -p "${service_config_paths[@]}"
		fs-own --user="$service_user" --group="$service_group" --permissions='g+rwx' \
			-- "${service_config_paths[@]}"
	}

	function run_official_linux_installer() (
		# run inside a subshell
		set +Eeuo # disable strict mode
		eval "$(fetch https://get.docker.com)"
	)
	function run_official_linux_checks() (
		# run inside a subshell
		set +Eeuo # disable strict mode
		eval "$(fetch https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh)"
	)
	function reset_firewall {
		# https://serverfault.com/a/200658/63348
		sudo-helper -- iptables -P INPUT ACCEPT
		sudo-helper -- iptables -P FORWARD ACCEPT
		sudo-helper -- iptables -P OUTPUT ACCEPT
		sudo-helper -- iptables -t nat -F
		sudo-helper -- iptables -t mangle -F
		sudo-helper -- iptables -F
		sudo-helper -- iptables -X
		sudo-helper -- ip6tables -P INPUT ACCEPT
		sudo-helper -- ip6tables -P FORWARD ACCEPT
		sudo-helper -- ip6tables -P OUTPUT ACCEPT
		sudo-helper -- ip6tables -t nat -F
		sudo-helper -- ip6tables -t mangle -F
		sudo-helper -- ip6tables -F
		sudo-helper -- ip6tables -X
		sudo-helper -- iptables -nvL
		sudo-helper -- ufw disable
		sudo-helper -- ufw status verbose
	}
	function configure_firewall {
		# https://docs.docker.com/network/bridge/#enable-forwarding-from-docker-containers-to-the-outside-world
		sudo-helper -- sysctl net.ipv4.conf.all.forwarding=1
		sudo-helper -- iptables -P FORWARD ACCEPT
		# https://docs.docker.com/config/daemon/ipv6/
		# /etc/docker/daemon.json doesn't seem to exist
	}
	function restart_docker {
		service-helper --disable --stop -- docker docker.socket containerd || :
		sleep 2
		service-helper --start -- containerd docker.socket docker || :
		sleep 2
		service-helper --status -- containerd docker.socket docker
	}
	function run_debug {
		eval-helper --no-quiet --wrap --shapeshifter \
			-- restart_docker

		# if failing to connect to your local dns serice
		# ensure it is listening to 0.0.0.0 instead of 127.0.0.1 or 127.0.0.53

		eval-helper --quiet --no-wrap --shapeshifter \
			-- docker run --rm -it \
			--net=host \
			--dns="$(what-is-my-dns exposed)" \
			-- alpine sh -c "$(cat "$DOROTHY/commands/debug-network")" || {
			local ec="$?"
			echo-style --notice='If failing, try restart your computer, and run:' ' ' --code='setup-util-docker --postinstall'
			return "$ec"
		}
	}
	function run_checks {
		eval-helper --quiet --wrap --shapeshifter \
			--pending="$(echo-style --bold="Testing hello-world container...")" \
			--success="$(echo-style --success="Verified hello-world.")" \
			--failure="$(echo-style --error="Failed to verify hello-world.")" \
			-- docker run --rm hello-world

		eval-helper --quiet --wrap --shapeshifter \
			--pending="$(echo-style --bold="Testing container gateway networking...")" \
			--success="$(echo-style --success="Verified container gateway networking.")" \
			--failure="$(echo-style --error="Failed to verify container gateway networking.")" \
			-- docker run --rm --net=host alpine ping -c4 "$(what-is-my-gateway)"

		eval-helper --quiet --wrap --shapeshifter \
			--pending="$(echo-style --bold="Testing container internet connection...")" \
			--success="$(echo-style --success="Verified container internet connection.")" \
			--failure="$(echo-style --error="Failed to verify container internet connection.")" \
			-- docker run --rm --net=host alpine ping -c4 cloudflare.com
	}
	function do_checks {
		eval-helper --quiet --no-wrap --shapeshifter \
			--pending="$(echo-style --bold="Testing Docker...")" \
			--success="$(echo-style --success="Docker is working.")" \
			--failure="$(echo-style --error="Failed to verify docker works.")" \
			-- run_checks || {
			local ec="$?"
			echo-style --notice='Debug with:' ' ' --code='setup-util-docker --debug'
			return "$ec"
		}
	}
	function run_postinstall {
		eval-helper --quiet --no-wrap --shapeshifter \
			--pending="$(echo-style --bold="Correcting permissions...")" \
			--success="$(echo-style --success="Corrected permissions.")" \
			--failure="$(echo-style --error="Failed to correct permissions.")" \
			-- add_permissions_to_config

		if is-linux; then
			eval-helper --quiet --no-wrap --shapeshifter \
				--pending="$(echo-style --bold="Restarting Docker...")" \
				--success="$(echo-style --success="Restarted Docker.")" \
				--failure="$(echo-style --error="Failed to restart Docker.")" \
				-- restart_docker

			eval-helper --quiet --no-wrap --shapeshifter \
				--pending="$(echo-style --bold="Running verification of Docker...")" \
				--success="$(echo-style --success="Verified Docker.")" \
				--failure="$(echo-style --error="Failed to verify Docker, however if the following checks pass, those were just warnings.")" \
				-- run_official_linux_checks || :
		fi

		do_checks
	}
	function check_docker_exists {
		command-exists docker
	}

	# simple actions
	if test "$action" = 'postinstall'; then
		run_postinstall
		return "$?"
	elif test "$action" = 'check'; then
		do_checks
		return "$?"
	elif test "$action" = 'debug'; then
		run_debug
		return "$?"
	fi

	# macos
	# https://docs.docker.com/desktop/install/mac-install/
	if is-mac; then
		setup-util "${util[@]}" --app='Docker' CASK='docker'
		while command-missing docker; do
			echo
			echo-style --code='docker' --dim=' command not found'
			echo-style --notice='Continue installation via the Docker app...'
			open "$(get-app 'Docker')"

			echo
			confirm --ppid=$$ -- 'Press <enter> once Docker has finished installing...'
		done
		do_checks
		# /Applications/Docker.app/Contents/MacOS/Docker --uninstall
	elif is-linux; then
		# uninstall
		if test "$action" = 'uninstall'; then
			echo
			echo 'Cleaning tooling...'
			if is-dnf; then
				# https://docs.docker.com/engine/install/fedora/
				sudo dnf remove docker \
					docker-client \
					docker-client-latest \
					docker-common \
					docker-latest \
					docker-latest-logrotate \
					docker-logrotate \
					docker-selinux \
					docker-engine-selinux \
					docker-engine || :
			elif command-exists apt-get snap; then
				# https://docs.docker.com/engine/install/ubuntu/
				sudo-helper -- apt-get purge -y \
					containerd \
					docker \
					docker-ce \
					docker-ce-cli \
					docker-ce-rootless-extras \
					docker-engine \
					docker.io \
					runc ||
					:
				sudo-helper -- snap remove --purge docker || :
				sudo-helper -- apt-get autoremove -y --purge || :
				sudo-helper -- dpkg --configure -a || :
				sudo-helper -- apt-get update || :
				sudo-helper -- apt-get -f install || :
			fi

			echo
			echo 'Cleaning files...'
			sudo-helper -- umount /var/lib/docker/ || :
			fs-rm --sudo -- "${service_uninstall_paths[@]}"

			if is-group "$service_group"; then
				echo
				echo 'Cleaning group...'
				delete_service_group
			fi

			echo
			echo-style --success='Docker successfully uninstalled.'

		elif test "$action" = 'install'; then
			# check if groups have failed, if so uninstall first
			# if docker is missing, then that's fine, we need to install
			if check_docker_exists && check_group && check_user_in_group; then
				echo-style --success='Docker already installed.'
			elif check_docker_exists && ! check_user_in_group; then
				echo-error "$0: Prior misconfigured docker installation detected."
				echo-style 'Try uninstall: ' --code='setup-util-docker --uninstall'
				echo-style 'Then install: ' --code='setup-util-docker'
				return 1
			elif ! check_docker_exists; then
				# https://forums.docker.com/t/installing-docker-on-ubuntu-16-04-lts-throws-error-for-command-linux-image-extra/21546?u=balupton
				# https://askubuntu.com/a/1236711/22776
				echo
				echo 'Installing dependencies...'
				setup-util-devel
				setup-util-snap --optional
				setup-util --optional --name='Kernel Virtualisation Helpers' \
					APT='linux-image-extra-virtual'

				echo
				echo 'Install using the official convenience script...'
				if ! run_official_linux_installer || command-missing docker; then
					echo-error "$0: Docker installation failed."
					return 1
				fi

				echo
				echo 'Configuring group...'
				if ! check_group; then
					# official installer may add the group for us
					add_service_group
				fi
				if ! check_user_in_group; then
					add_service_users_to_service_group

					# echo
					#
					# this works, however it fails on tty items
					echo "$0 --postinstall" | newgrp "$service_group" || {
						echo-style --notice='Failed to automatically postinstall, you must restart your computer, then run:'
						echo-style '    ' --code='setup-util-docker --postinstall'
						if confirm --positive --ppid=$$ -- "Restart now?"; then
							sudo-helper -- shutdown --reboot
						else
							return 1
						fi
					}
					return "$?"
				fi
			else
				echo-error "$0: Invalid state."
				return 1
			fi
		fi # end install
	fi  # end os

)

# fire if invoked stqandalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup-util-docker "$@"
fi

# =====================================
# DOCKER NETWORKING

# https://docs.docker.com/network/bridge
# https://docs.docker.com/network/bridge/#access-the-outside-world-from-a-container
# by default docker0 bridge is used, which is often invalid
# you can create a correctly configured bridge network with
#
# eval-helper --no-quiet --wrap --shapeshifter \
# 	-- reset_firewall
#
# eval-helper --no-quiet --wrap --shapeshifter \
# 	-- configure_firewall
#
# sudo-helper -- systemctl daemon-reload
#
# docker network rm web || :
# docker network create \
# 	--driver bridge \
# 	--subnet "$(what-is-my-subnet)" \
# 	--gateway "$(what-is-my-gateway)" \
# 	--opt parent="$(what-is-my-interface)" \
# 	web
#
# however all BRIDGES cannot access the outside internet, only HOST can access the outside world, this is intentional design by docker
# as such you must use the HOST network
#
# firewall changes and these flags have no effect
#
# --cap-add=NET_ADMIN --privileged --net=web

# =====================================
# RELOAD DOCKER

# try-sudo systemctl restart docker
# try-sudo systemctl reload docker
# try-sudo service docker restart

# network
# echo 'create docker network'
# docker network rm web || echo
# try-sudo systemctl restart docker
# try-sudo systemctl reload docker
# try-sudo service docker restart

# docker network create \
# 	--driver bridge \
# 	--subnet 192.168.0.0/16 \
# 	--gateway 192.168.4.1 \
# 	--opt parent=eth0 \
# 	web
# docker network ls

# =====================================
# DEBUG DOCKER

# https://developer.ibm.com/technologies/linux/tutorials/l-lpic1-109-4/

# NOTE: https://docs.docker.com/network/bridge/#use-the-default-bridge-network
# The default bridge network is considered a legacy detail of Docker and is not recommended for production use. Configuring it is a manual operation, and it has technical shortcomings.

# works:
# --net=host

# fails:
# --net=bridge
# --net=bridge --dns 9.9.9.9
# --net=bridge --dns=9.9.9.9 --dns-search=raspi8
# --dns-opt='DNSSEC=true' --dns-opt='DNSOverTLS=opportunistic'
# --net=bridge --dns 9.9.9.9
# try-sudo ... --privileged --net=bridge --dns=9.9.9.9
#  --dns-opt='edns0 trust-ad'
#  --dns-search='lan'
# --network web \

# alpine \
#	sh -c 'apk add curl bind-tools;

# try-sudo docker run -ti mmoy/ubuntu-netutils bash

# ubuntu \
# 	sh -c 'apt update -y; apt install -y curl dnsutils;

# set -x
# try-sudo docker run --rm --cap-add=NET_ADMIN --net=bridge --dns="$(what-is-my-dns exposed)" alpine sh -c "$(cat "$DOROTHY/commands/debug-network")"
# set +x
