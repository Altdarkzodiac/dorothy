#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/shims.bash"
# trunk-ignore(shellcheck/SC1090)
source "$(which eval-helper)"

function setup-linux() (
	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Configure Linux to our expectations.

			USAGE:
			setup-linux <install|update>
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# process
	local item action=''
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*)
			if test -z "$action"; then
				action="$item"
			else
				help "An unrecognised argument was provided: $item"
			fi
			;;
		esac
	done

	# assert operating system
	if ! is-linux; then
		help "This command is only purposeful on Linux systems, which you are not running."
	fi

	# assert action
	if test -z "$action"; then
		help "No action provided."
	fi

	# generate log title
	local title
	title="$(ucf "$action") Linux"

	# =====================================
	# Configuration

	source "$DOROTHY/sources/config.bash"

	# setup.bash provides:
	local APT_INSTALL=()
	local APT_UNINSTALL=()
	local APT_ADD=()    # deprecated, use APT_INSTALL
	local APT_REMOVE=() # deprecated, use APT_UNINSTALL
	local APK_INSTALL=()
	local SNAP_INSTALL=()
	load_dorothy_config 'setup.bash'

	# adjustments
	mapfile -t APT_INSTALL < <(prepare_packages 'APT_INSTALL' -- "${APT_INSTALL[@]}" "${APT_ADD[@]}")
	mapfile -t APT_UNINSTALL < <(prepare_packages 'APT_UNINSTALL' -- "${APT_UNINSTALL[@]}" "${APT_REMOVE[@]}")
	mapfile -t APK_INSTALL < <(prepare_packages 'APK_INSTALL' -- "${APK_INSTALL[@]}")
	mapfile -t SNAP_INSTALL < <(prepare_packages 'SNAP_INSTALL' -- "${SNAP_INSTALL[@]}")

	# =====================================
	# Helpers

	# updates
	local updates=('apt' 'apk' 'yum' 'pacman' 'zypper')
	function do_apt_update {
		sudo apt-get update -y
	}
	function do_apk_update {
		apk update
	}
	function do_yum_update {
		sudo yum check-update -y || : # it always returns exit code 100
	}
	function do_pacman_update {
		# init the local database
		# this is needed on systems which pacman was installed
		sudo pacman-key --init
		# refresh the local database
		sudo pacman --refresh --sync --noconfirm
	}
	function do_zypper_update {
		sudo zypper refresh
	}
	# pamac/flatpak do not have update without upgrade

	# upgrades
	local upgrades=('apt' 'yum' 'snap' 'flatpak' 'pamac')
	function do_apt_upgrade {
		# `full-upgrade` is the same as `dist-upgrade` apparently, which is a more automatic/comprehensive upgrader compared to `apt-get upgrade`
		sudo apt-get full-upgrade -y
	}
	function do_yum_upgrade {
		sudo yum upgrade -y
	}
	function do_snap_upgrade {
		if ! is-snap; then
			return 0
		fi
		sudo snap refresh
	}
	function do_flatpak_upgrade {
		sudo flatpak update -y
		# ^ sudo with flatpak avoids gui sudo prompt
	}
	function do_pamac_upgrade {
		# pacmac upgrade/update are exactly the same
		sudo pamac upgrade --no-confirm # --aur
		# ^ sudo with pamac avoids gui sudo prompt
	}

	# system
	function do_apt_system {
		if ! command-exists do-release-upgrade; then
			return 0
		fi
		# check for a new distro release
		if do-release-upgrade -c; then
			# if there is one, then ask the user if they want to upgrade to it
			if confirm-negative --ppid=$$ -- 'Upgrade the distribtion release?'; then
				sudo do-release-upgrade
			fi
		fi
	}

	# packages
	local packages=('apt' 'apk' 'snap')
	function do_apt_packages {
		# apt uninstall
		if test -n "${APT_UNINSTALL[*]}"; then
			setup-util --uninstall \
				NAME="apt:${APT_UNINSTALL[*]}" \
				APT="${APT_UNINSTALL[*]}"
		fi

		# apt install
		if test -n "${APT_INSTALL[*]}"; then
			setup-util \
				NAME="apt:${APT_INSTALL[*]}" \
				APT="${APT_INSTALL[*]}"
		fi
	}
	function do_apk_packages {
		if test -n "${APK_INSTALL[*]}"; then
			setup-util \
				NAME="apk:${APK_INSTALL[*]}" \
				APK="${APK_INSTALL[*]}"
		fi
	}
	function do_snap_packages {
		if ! is-snap; then
			return 0
		fi
		if test -n "${SNAP_INSTALL[*]}"; then
			setup-util \
				NAME="snap:${SNAP_INSTALL[*]}" \
				SNAP="${SNAP_INSTALL[*]}"
		fi

		# configure with
		# snap list --color=never | sed '1d' | cut -d' ' -f1 | grep --invert-match --extended-regexp --regexp='^(core|snapd)'
	}

	# clean
	local clean=('apt' 'pamac' 'pacman')
	function do_apt_clean {
		sudo apt-get autoremove -y --purge
		sudo apt-get autoclean -y
		sudo apt-get clean -y
	}
	function do_pamac_clean {
		sudo pamac clean --no-confirm
		# ^ sudo with pamac avoids gui sudo prompt
	}
	function do_pacman_clean {
		# -c, --clean
		#   Remove packages that are no longer installed from the cache as well as currently unused sync databases to free up disk space.
		sudo pacman --sync --noconfirm --clean
	}

	# =====================================
	# Action

	# prepare
	local item

	# log
	echo-segment --h1="$title"

	# update references
	for item in "${updates[@]}"; do
		if command-exists "$item"; then
			eval-helper --shapeshifter --no-wrap \
				--pending="$(echo-style --bold="Updating references of $item...")" \
				--success="$(echo-style --success="Updated references of $item.")" \
				--failure="$(echo-style --error="Failed to update references of $item.")" \
				-- "do_${item}_update"
		fi
	done

	# setup essential system utilities
	setup-util-devel
	setup-linux-raspi
	setup-linux-recovery

	# install package managers
	if test "$action" = 'install'; then
		# in this order, based on dependency relationships
		setup-util-pamac --optional --confirm
		setup-util-snap --optional --confirm
		setup-util-flatpak --optional --confirm
		setup-util-gnome-software --optional --confirm
	fi

	# upgrade all packages
	# ask, because manjaro and other rolling releases can demand over 40GB for initial upgrades
	if confirm-positive --ppid=$$ -- "Upgrade existing packages?"; then
		for item in "${upgrades[@]}"; do
			if command-exists "$item"; then
				eval-helper --shapeshifter --no-wrap \
					--pending="$(echo-style --bold="Upgrading packages of $item...")" \
					--success="$(echo-style --success="Upgraded packages of $item.")" \
					--failure="$(echo-style --error="Failed to upgrade packages of $item.")" \
					-- "do_${item}_upgrade"
			fi
		done
	fi

	# upgrade the entire system
	do_apt_system

	# setup user packages
	for item in "${packages[@]}"; do
		if command-exists "$item"; then
			eval-helper --shapeshifter --no-wrap \
				--pending="$(echo-style --bold="Installing packages of $item...")" \
				--success="$(echo-style --success="Installed packages of $item.")" \
				--failure="$(echo-style --error="Failed to install packages of $item.")" \
				-- "do_${item}_packages"
		fi
	done

	# cross-platform
	setup-extras "$action"

	# cleanup
	for item in "${clean[@]}"; do
		if command-exists "$item"; then
			eval-helper --shapeshifter --no-wrap \
				--pending="$(echo-style --bold="Tidying $item...")" \
				--success="$(echo-style --success="Tidied $item.")" \
				--failure="$(echo-style --error="Failed to tidy $item.")" \
				-- "do_${item}_clean"
		fi
	done

	# setup fonts last, as it takes forever
	setup-linux-fonts || : # don't care for failures, as fonts are optional

	# log
	echo-segment --g1="$title"
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	setup-linux "$@"
fi
