#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/arrays.bash"
has_array_support 'mapfile'

function btrfs-helper() (
	# =====================================
	# Arguments

	function help {
		cat <<-EOF >/dev/stderr
			ABOUT:
			Wrappers around btrfs to make things easier.

			USAGE:
			btrfs-helper <action>

			ACTIONS:
			drives
			    Lists all attached drives that are formatted to btrfs.

			drive -- <btrfs-filesystem-label>
			    Gets the primary drive for the btrfs filesystem label.

			mounts
			    Lists all mount points which btrfs formatted drives are attached to.

			new
			    Prompts you to select a drive to erase and format to btrfs.

			add
			    Prompts you to select a drive, and an existing btrfs mount point, to add the drive to.

			balance
			    Prompts you to select a btrfs mount point, to run a btrfs raid1 balance on.

			verify -- <btrfs-filesystem-label> <expected-count-of-btrfs-filesystem-drives>
			    Verifies that the drive count for a btrfs filesystem label is correct.

			mounted -- <btrfs-filesystem-label> <expected-mount-point>
			    Verifies that the btrfs filesystem label is mounted to the expected mount point.
		EOF
		if test "$#" -ne 0; then
			echo-error "$@"
		fi
		return 22 # Invalid argument
	}

	# process
	local item action='' args=()
	while test "$#" -ne 0; do
		item="$1"
		shift
		case "$item" in
		'--help' | '-h') help ;;
		'--')
			args+=("$@")
			shift $#
			break
			;;
		'--'*) help "An unrecognised flag was provided: $item" ;;
		*)
			if test -z "$action"; then
				action="$item"
			else
				help "An unrecognised argument was provided: $item"
			fi
			;;
		esac
	done

	# ensure valid action
	local actions=(
		drives
		drive
		mounts
		new
		add
		balance
		verify
		mounted
	)
	action="$(
		choose-option --required \
			--question='What action to perform?' \
			--filter="$action" -- "${actions[@]}"
	)"

	# =====================================
	# Dependencies

	source "$DOROTHY/sources/ripgrep.bash"

	# =====================================
	# Helpers

	# Get all the mount points which btrfs drives are mounted to
	function get_btrfs_mounts {
		df -Th | awk '($2 == "btrfs") {print $7}'
		# lsblk -f | awk '($2 == "btrfs" && $7) {print $7}'
	}

	# Prompt for a specific btrfs mount point
	function get_btrfs_mount {
		local question="$1" mounts
		mapfile -t mounts < <(btrfs_mounts)
		choose-option --required \
			--question="$question" \
			-- "${mounts[@]}"
	}

	# Prompt for a specific drive
	function get_any_drive {
		local question="$1" drives=()
		mapfile -t drives < <(get-drives)
		choose-option --required \
			--question="$question" \
			-- "${drives[@]}"
	}

	# Get all the drives which are formatted to btrfs
	function get_btrfs_drives {
		lsblk -f | awk '/btrfs/ {print "/dev/"$1}'
	}

	# Prompt for a specific btrfs drive
	function get_btrfs_drive {
		local question="$1" drives=()
		mapfile -t drives < <(get_btrfs_drives)
		choose-option --required \
			--question="$question" \
			-- "${drives[@]}"
	}

	# Get the primary drive of a btrfs filesystem label
	function get_btrfs_drive_for_label {
		local label="$1"
		blkid -L "$label"
	}

	# Get the drives of a btrfs filesystem label
	function get_btrfs_drives_for_label {
		local label="$1"
		sudo-helper \
			-- btrfs filesystem show "$label" | rg -o 'path ([a-z0-9/]+)' --replace '$1'
	}

	# Count the drives of a btrfs filesystem label
	function get_btrfs_count_for_label {
		local label="$1"
		sudo-helper \
			-- btrfs filesystem show "$label" | rg -o 'Total devices ([0-9]+)' --replace '$1'
	}

	# =====================================
	# Actions

	function act_mounts {
		get_btrfs_mounts
	}

	function act_drives {
		get_btrfs_drives
	}

	function act_new {
		local drive label
		drive="$(
			get_any_drive "Which drive to erase and format as btrfs?"
		)"
		label="$(
			ask --required \
				--question="What label to use for the new btrfs filesystem that will be attached to the drive [$drive]?"
		)"
		eval-helper --quiet=no --confirm \
			-- sudo-helper \
			-- mkfs.btrfs -f -L "$label" "$drive"
	}

	# Add a drive to a btrfs cluster
	function act_add {
		local drive mount
		echo 'You will now specify a mount point of an existing btrfs cluster, and a drive that you wish to be erased and added to it.'
		mount="$(get_btrfs_mount "Which mount point is the btrfs cluster that will house the new drive?")"
		drive="$(get_any_drive "Which drive is the one to be erased then added into the btrfs cluster?")"

		# add the drive to the mount point
		eval-helper --quiet=no --confirm \
			-- sudo-helper \
			-- btrfs device add -f "$drive" "$mount"

		# balance the drives of the mount point
		eval-helper --quiet=no --confirm \
			-- sudo-helper \
			-- btrfs balance start --background -dconvert=raid1 -mconvert=raid1 "$mount"
	}

	# Resume a balance
	function act_balance {
		local mount
		mount="$(get_btrfs_mount "Which btrfs mount point should we resume/start a btrfs raid1 balance operation on?")"

		if eval-helper --quiet=no \
			-- sudo-helper \
			-- btrfs balance status -v "$mount"; then

			# finished
			eval-helper --quiet=no \
				-- sudo-helper \
				-- btrfs balance start --background -dconvert=raid1 -mconvert=raid1 "$mount"
		else
			# in progress
			eval-helper --quiet=no \
				-- sudo-helper \
				-- btrfs balance resume "$mount"
		fi
	}

	# Verify the amount of btrfs drives matches the expected ount
	function act_verify {
		local label="$1" expected="$2" actual
		actual="$(get_btrfs_count_for_label "$label")"
		if test "$actual" -ne "$expected"; then
			cat <<-EOF >/dev/stderr
				$(echo-style --error="$actual out of $expected drives available")
				$(echo-style --notice="Try again when all drives are available.")
			EOF
			return 1
		fi
	}

	function act_mounted {
		local label="$1" mount="$2" drive
		drive="$(get_btrfs_drive_for_label "$label")"
		is-mounted --source="$drive" --target="$mount"
	}

	function act_drive {
		local label="${1-}"
		if test -n "$label"; then
			get_btrfs_drive_for_label "$label"
		else
			get_btrfs_drive 'Which btrfs drive to select?'
		fi
	}

	# =====================================
	# Act

	if test "$(type -t "act_$action")" = 'function'; then
		"act_$action" "${args[@]}"
		return "$?"
	else
		echo-style --error="Action [$action] not yet implemented." >/dev/stderr
		return 78 # Function not implemented
	fi
)

# fire if invoked standalone
if test "$0" = "${BASH_SOURCE[0]}"; then
	btrfs-helper "$@"
fi
