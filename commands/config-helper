#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile'

# dependencies
source "$DOROTHY/sources/ripgrep.bash"

# test
if is-needle '--test' "$@"; then
	(
		# prepare
		echo-segment --h1="TEST: $0"
		echo
		file="$(mktemp)"

		# test invalid arguments fail
		eval-tester --ec=22 -- config-helper --file="$file"
		eval-tester --ec=22 -- config-helper --file="$file" --replace='one'
		eval-tester --ec=22 -- config-helper --file="$file" --find='one' --replace='one' --replace='two'
		eval-tester --ec=22 -- config-helper --file="$file" --find='one' --find='two' --replace='one'

		# test an empty file
		eval-tester -- config-helper --file="$file" \
			--find='commands.local/' --replace='commands.local/' \
			--find='config.local/' --replace='config.local/'
		eval-tester --stdout=$'commands.local/\nconfig.local/' -- cat "$file"

		# test a file that as results
		eval-tester -- config-helper --file="$file" \
			--find='commands.local/' --replace='commands.replaced/' \
			--find='config.local/' --replace='config.replaced/'
		eval-tester --stdout=$'##commands.local/\ncommands.replaced/\n##config.local/\nconfig.replaced/' -- cat "$file"

		# test find only, used by <sharebox> commandd
		echo $'\tUser=uu\n\tGroup=gg\n\t# Party=pp' >>"$file"
		eval-tester --stdout='uu' -- \
			config-helper --file="$file" --find='User=(.*)'
		eval-tester --stdout=$'uu\ngg' -- \
			config-helper --file="$file" --find='User=(.*)' --find='Group=(.*)'

		# test unused but possible find patterns
		eval-tester --stdout=$'##commands.local/\ncommands.replaced/' -- config-helper --file="$file" \
			--find='##commands.local/' \
			--find='commands.replaced/'
		eval-tester --stdout=$'User=uu\nGroup' -- \
			config-helper --file="$file" --find='User=.*' --find='(Group)=.*' --find='Party'

		# todo, add tests for:
		# -- find, replace
		# -- find, (multiline replace)

		# done
		echo-segment --g1="TEST: $0"
	)
	exit "$?"
fi

# =====================================
# Arguments

# help
function help() {
	cat <<-EOF >/dev/stderr
		USAGE:
		config-helper <file> [--find=<pattern> --replace=<pattern>]...
		config-helper <file> [--find=<pattern>]...
		config-helper <file> -- [<find> <replace>]...

		QUIRKS:

		[--find=<pattern>] and [--replace=<pattern>] used rust based regular expressions.

		<find> and <replace> use key-value pair replacements.

		If replace is omitted, that is only finds are provided, then config-helper servers as a value fetcher.

		If replace is provided, then config-helper will update the <file> with the replacements.
	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# e.g.
# /etc/systemd/resolved.conf
# shell.sh
# .gitignore
file=''

# e.g.
# Domains=
# DOROTHY_THEME=
# config.local/
find_array=()

# e.g.
# Domains=~.
# DOROTHY_THEME=oz
# config.local/
replace_array=()

# e.g.
# Domains, ~.
# DOROTHY_THEME, oz
args=()

# process
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	'--help' | '-h') help ;;
	'--file='*) file="${item:7}" ;;
	'--find='*) find_array+=("${item:7}") ;;
	'--replace='*) replace_array+=("${item:10}") ;;
	'--')
		args+=("$@")
		shift $#
		break
		;;
	'--'*) help "An unrecognised flag was provided: $item" ;;
	*)
		if test -z "$file"; then
			file="$item"
		else
			help "An unrecognised argument was provided: $item"
		fi
		;;
	esac
done

# check if args is provided, as we will need to process it
if test "${#args[@]}" -ne 0; then
	if is-odd "${#args[@]}"; then
		help "The amount of args must be even, as they are for [<find> <replace>] tuples."$'\n'"$(echo-verbose "${args[@]}")"
	fi
	for ((i = 0; i < ${#args[@]}; i = i + 2)); do
		key="${args[i]}"
		input="${args[i + 1]}"
		mapfile -t values < <(echo-split $'\n' -- "$input" | sort)
		find="${key}=(?:.*)"
		if test "${#values[@]}" -eq 0; then
			replace=''
		else
			if test "${#values[@]}" -eq 1; then
				# single value
				value="${values[0]@Q}"
			else
				# array
				# https://github.com/chmln/sd/issues/146
				find="${key}=(?:[(](?:\n|.)*?[)]|.*)"
				value=$'('
				for line in "${values[@]}"; do
					value+=$'\n\t'"${line@Q}"
				done
				value+=$'\n)'
			fi
			replace="${key}=${value}"
		fi
		# multiline replace
		if rg -Uq "$find" "$file"; then
			# it was found, so do the replacement
			sd -f m "$find" "$replace" "$file"
		else
			# wasn't found, add manually
			if test -n "$replace"; then
				echo "$replace" >>"$file"
			fi
		fi
	done
	# we do our own processing, as we need to support multiline matches
	echo "Updated configuration file: $file"
	exit 0
fi

# prepare verify
find_count="${#find_array[@]}"
replace_count="${#replace_array[@]}"

# verify find
if test "$find_count" -eq 0; then
	stderr echo-style \
		--error="$0 $*" $'\n' \
		--red="At least one [--find=...] argument must be provided."
	exit 22 # Invalid argument
fi

# check if we are find only
# if so, life is simple, do a little thing then exist
if test "$replace_count" -eq 0; then
	# we are find only
	for find in "${find_array[@]}"; do
		if rg -q '[(].+?[)]' <<<"$find"; then
			pattern="^[ 	]*(?:$find)$"
		else
			pattern="^[ 	]*($find)$"
		fi
		# ^ with indentation but no comment (so we only get real values), and with value group so that $2 is consistent with overrides
		rg -o "$pattern" --replace '$1' "$file" || :
		# ^ don't fail on no results
	done
	exit
fi
# otherwise we are a replacement
# goal: replace all uncommented instances with a single set instance, after the first comment or at the end

# verify we have the same finds as replaces
if test "$replace_count" -ne "$find_count"; then
	stderr echo-style \
		--error="$0 $*" $'\n' \
		--red="the amount of [--find=...] arguments must match the amount of [--replace=...] arguments."
	exit 22 # Invalid argument
fi

# prepare the file
touch "$file"
mapfile -t lines <"$file"

# cycle through each find and replace pair
for find_index in "${!find_array[@]}"; do
	# prepare
	find="${find_array[find_index]}"
	replace="${replace_array[find_index]}"
	pattern="^([ 	]*)[# 	]*($find)$" # with indentation, with comment
	found='no'
	stack=()
	results=()

	# cycle through the lines
	# `test ... && for ...` is for bash v3 compatibility
	test "${#lines[@]}" -ne 0 && for line in "${lines[@]}"; do
		# check if the lines matches the pattern
		if prefix="$(rg -qo "$pattern" --replace '$1' <<<"$line")"; then
			# if not found, add the replacement line to the stack, to be added when we get back to normal lines
			if test "$found" = 'no'; then
				stack+=(
					"${prefix}${replace}"
				)
				found='yes'
			fi

			# get existing line, minus comment prefix
			comment="$(rg -o "$pattern" --replace '$2' <<<"$line")"

			# only add the comment, if it is different from the result
			if test "$comment" != "${replace}"; then
				# use ## so it is easy to see where the replacements were
				results+=(
					"${prefix}##${comment}"
				)
			fi
		else
			# not a match, so ordinary line

			# empty the stack
			if test "${#stack[@]}" -ne 0; then
				results+=("${stack[@]}")
				stack=()
			fi

			# and append
			results+=("$line")
		fi
	done

	# empty the stack
	if test "${#stack[@]}" -ne 0; then
		results+=("${stack[@]}")
		stack=()
	fi

	# append replacement if it was never found
	if test "$found" = 'no'; then
		results+=("$replace")
	fi

	# replace the lines with the results, and move onto the next combo
	lines=("${results[@]}")
done

# write the updated file
echo-lines "${results[@]}" >"$file"
echo "Updated configuration file: $file"
