#!/usr/bin/env bash
source "$DOROTHY/sources/strict.bash"
source "$DOROTHY/sources/arrays.bash"
requires_array_support 'mapfile'

# dependencies
source "$DOROTHY/sources/ripgrep.bash"
env QUIET=yes setup-util-sd

# test
if is-needle '--test' "$@"; then
	(
		# prepare
		echo-segment --h1="TEST: $0"
		echo
		file="$(mktemp)"

		# test invalid arguments fail
		eval-tester --ec=22 -- config-helper --file="$file"
		eval-tester --ec=22 -- config-helper --file="$file" -- --replace='one'
		eval-tester --ec=22 -- config-helper --file="$file" -- --find='a' --replace='one' --replace='two'
		eval-tester --stdout='one' -- cat "$file"

		# test an empty file
		eval-tester -- config-helper --file="$file" -- \
			--find='commands.local[/]' --replace='commands.local/' \
			--find='config.local[/]' --replace='config.local/'
		eval-tester --stdout=$'one\ncommands.local/\nconfig.local/' -- cat "$file"

		# test a file that as results
		eval-tester -- config-helper --file="$file" -- \
			--find='commands.local[/]' --replace='commands.replaced/' \
			--find='config.local[/]' --replace='config.replaced/'
		eval-tester --stdout=$'one\ncommands.replaced/\nconfig.replaced/' -- cat "$file"

		# test find only, used by <sharebox> command
		echo $'User=uu\n\tGroup=gg\n\t# Party=pp' >"$file"
		eval-tester --stdout=$'User=uu\nuu\nGroup=gg\ngg' -- config-helper --file="$file" -- \
			--find='User=(.*)' \
			--field='User' \
			--find='Group=(.*)' \
			--field='Group' \
			--find='Party=(.*)' \
			--field='Party'

		# uncomment party
		eval-tester --stdout='sup' -- config-helper --quiet --file="$file" -- \
			--find='Party=(.*)' --replace='Party=sup' \
			--field='Party'

		# test variable replacements
		echo $'a=one\n\tb=(two three)\n\ta=three\n\tb=(four five)' >"$file"
		eval-tester -- config-helper --quiet --file="$file" -- \
			--field='a' --value='1' \
			--field='b' --array="$(echo-lines --quoted 2 3)"
		eval-tester --stdout=$'a=1\n\tb=(\n\t\t\'2\'\n\t\t\'3\'\n\t)' -- cat "$file"

		# done
		echo-segment --g1="TEST: $0"
	)
	exit "$?"
fi

# =====================================
# Arguments

# help
function help() {
	cat <<-EOF >/dev/stderr
		USAGE:
		config-helper <file> -- ...
			[--find=<pattern>] # outputs the found result
			[--find=<pattern> [--replace=<pattern>]] # replaces the pattern with the pattern
			[--field=<field>] # outputs the value of the field
			[--field=<field> [--value=<value>]] # sets the field to the value
			[--field=<field> [--array=<lines>]] # sets the field to an array of the lines

		QUIRKS:
		If a commented --find=<pattern> or --field=<field> is found, the replacement will be placed there.
		If multiple results are found, the replacement will only leave the replacement.
	EOF
	if test "$#" -ne 0; then
		echo-style $'\n' --error="ERROR:" $'\n' --red="$(echo-lines "$@")" >/dev/stderr
	fi
	return 22 # Invalid argument
}

# e.g.
# /etc/systemd/resolved.conf
# shell.sh
# .gitignore
file=''

# process
args=()
quiet='no'
while test "$#" -ne 0; do
	item="$1"
	shift
	case "$item" in
	'--help' | '-h') help ;;
	'--file='*) file="${item:7}" ;;
	'--quiet'*) quiet="$(get-flag-value quiet --missing="$quiet" -- "$item" | echo-affirmative)" ;;
	'--')
		args+=("$@")
		shift $#
		break
		;;
	'--'*) help "An unrecognised flag was provided: $item" ;;
	*)
		if test -z "$file"; then
			file="$item"
		else
			help "An unrecognised argument was provided: $item"
		fi
		;;
	esac
done

# check
if test "${#args[@]}" -eq 0; then
	help "Need arguments, otherwise what is the point?"
fi

# =====================================
# Action

# prepare
update='no'

# cycle
function act() {
	local search sed_trim_duplicates get_value_pattern pattern replace find field value
	while test "$#" -ne 0; do
		# prepare
		search="$1"
		shift
		sed_trim_duplicates=''
		get_value_pattern=''
		pattern=''
		replace="${1-}"
		find=''
		field=''
		value=''

		# search
		# https://docs.rs/regex/latest/regex/
		# (?flags:exp)   set flags for exp (non-capturing)
		# m     multi-line mode: ^ and $ match begin/end of line
		# u     Unicode support (enabled by default)
		# x     ignore whitespace and allow line comments (starting with `#`)
		# ^ x doesn't seem to work
		# sed magic is from https://unix.stackexchange.com/a/569675/50703
		# the (?m) prefix turns out not be necessary, for sed, nor ripgrep
		if [[ "$search" = '--pattern='* ]]; then
			# raw pattern
			pattern="(?P<value>${search:10})" # undocumented
		elif [[ "$search" = '--find='* ]]; then
			# indentable, commentable, pattern
			find="${search:7}"
			pattern="^(?P<indent>[[:blank:]]*)(?P<comment>(?:#|[[:blank:]])*)(?P<value>${find})$"
			get_value_pattern="^(?P<indent>[[:blank:]]*)(?P<value>${find})$" # ignore comments
			sed_trim_duplicates="0,/[# 	]*${find}/!{//d}"
		elif [[ "$search" = '--field='* ]]; then
			# field that can be an array and value
			field="${search:8}"
			pattern="^(?P<indent>[[:blank:]]*)(?P<comment>(?:#|[[:blank:]])*)${field}=(?P<value>[(](?ms:.*?)[)]|[^\n]*)$"
			get_value_pattern="^(?P<indent>[[:blank:]]*)${field}=(?P<value>[(](?ms:.*?)[)]|[^\n]*)$" # ignore comments
			sed_trim_duplicates="0,/[# 	]*${field}=(.*?)/!{//d}"
		else
			help "Invalid search argument [$search] it must be either --find=<pattern> or --field=<field>"
		fi

		# replace
		if [[ "$replace" = '--replace='* ]]; then
			# replace value
			replace="${replace:10}"
		elif [[ "$replace" = '--array='* ]]; then
			value="${replace:8}"

			# check for field
			if test -z "$field"; then
				help "--array=<$value> must be used with --field=<field>"
			fi

			# adapt for array
			mapfile -t lines <<<"$value" # read lines into an array, such that indentation works
			value=$'(\n'"$(echo-lines --indent=$'${indent}\t' "${lines[@]}")"$'\n${indent})'
			replace="\${indent}${field}=${value}"
		elif [[ "$replace" = '--value='* ]]; then
			value="${replace:8}"

			# check for field
			if test -z "$field"; then
				help "--value=<$value> must be used with --field=<field>"
			fi

			# apply for value
			replace="\${indent}${field}=${value}"
		else
			# this was a find only
			# --max-count=1 is to workaround: https://github.com/BurntSushi/ripgrep/issues/2095
			rg --max-count=1 --multiline --only-matching "${get_value_pattern:-"$pattern"}" --replace '${value}' "$file" || :
			continue
		fi

		# it was a valid replace, so trim the replace value, so it is not the next iteration
		shift
		update='yes'

		# and perform the replace
		if rg --quiet --multiline "$pattern" "$file"; then
			# trim all but the first occurance, this is complicated because these aren't a thing:
			# https://github.com/BurntSushi/ripgrep/issues/2094
			# https://github.com/chmln/sd/issues/105
			# https://github.com/greymd/teip/issues/27
			if test -n "$sed_trim_duplicates"; then
				if test -n "$field"; then
					# make everything a single line, as gsed can't do multiple lines
					sd "$pattern" "\${indent}${field}=$RANDOM" "$file"
				fi
				# trim everything but the first occurance
				gsed -i -E "$sed_trim_duplicates" "$file"
			fi

			# it was found, use sd for the replacement
			sd "$pattern" "$replace" "$file"
		else
			# it wasn't found, so add manually if it's not empty
			if test -n "$replace"; then
				echo "$replace" >>"$file"
			fi
		fi
	done
}

# act
act "${args[@]}"

# we do our own processing, as we need to support multiline matches
if test "$update" = 'yes' -a "$quiet" = 'no'; then
	echo-style --success="Updated configuration file: $file" >/dev/tty
fi
